{"pages":[{"title":"about","text":"个人博客，仅供学习","link":"/about/index.html"}],"posts":[{"title":"IDEA中lombok插件离线安装","text":"因为网络问题，安装lombok一直失败，所以这次采用插件包离线安装 下载插件包，插件包有两个地方可以下载，分别是IDEA的官方插件仓库和GitHub里lombok-intellij-plugin仓库 IDEA：http://plugins.jetbrains.com/plugin/6317-lombok-plugin Github：https://github.com/mplushnikov/lombok-intellij-plugin/releases 我这里采用Github仓库的 对照自己下载的IDEA版本下载指定的插件包 文件下载 不清楚自己IDEA的，可依次进入IDEA-----&gt; Help —&gt;About查看 安装插件包 依次进入IDEA —&gt; Settings -----&gt;Plugins 点击第三个选项，找到刚才下载的lombok插件包的位置进行安装，完成后重启IDEA 这样就安装完成了 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt;&lt;/dependency&gt;","link":"/2020/02/17/IDEA%E4%B8%ADlombok%E6%8F%92%E4%BB%B6%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85/"},{"title":"MyBatis框架学习一","text":"mysql : 8.0 概述 持久层技术解决方案： JDBC技术： Connection PreparedStatement ResultSet Spring的JdbcTemplate: Spring中对jdbc的封装 Apache的DButils： 与Spring的JdbcTemplate很像，也是对Jdbc的封装 以上这些都不是框架，JDBC是规范，Spring的JdbcTemplate和Apache的DButils都只是工具类 MyBatis框架概述： Mybatis是apache的一个开源项目iBatis，2010年这个项目由apache software foundation迁移到了google code，并且改名为Mybatis，2013年迁移到Github Mybatis是一个数据持久化的开源框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建链接、创建statement等过程。 mybatis可通过xml或注解的方式将要执行的statement语句配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。 采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，是我们不用与Jdbc api打交道，就可以完成对数据库的持久化操作。 创建Mysql用户测试表 12345678create table user( id int(10) not null auto_increment, username varchar(30) not null comment '用户名称', birthday datetime default null comment '生日', sex char(1) default null comment '性别', address varchar(100) default null comment '地址', primary key (id))ENGINE =InnoDB DEFAULT CHARSET =utf8; 插入数据 环境配置 导入依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.15&lt;/version&gt;&lt;/dependency&gt; 创建实体类的接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.io.Serializable;import java.util.Date;public class User implements Serializable { private static final long serialVersionUID=1L; private Integer id; private String username; private Date birthday; private String sex; private String address; public static long getSerialVersionUID() { return serialVersionUID; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Date getBirthday() { return birthday; } public void setBirthday(Date birthday) { this.birthday = birthday; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public User(Integer id, String username, Date birthday, String sex, String address) { this.id = id; this.username = username; this.birthday = birthday; this.sex = sex; this.address = address; } public User() { } @Override public String toString() { return \"User{\" + \"id=\" + id + \", username='\" + username + '\\'' + \", birthday=\" + birthday + \", sex='\" + sex + '\\'' + \", address='\" + address + '\\'' + '}'; }} 在resource文件下创建Mybatis的主配置文件 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!--mybatis主配置文件--&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default=\"mysql\"&gt; &lt;!--配置mysql的环境--&gt; &lt;environment id=\"mysql\"&gt; &lt;!--配置事务的类型--&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!--配置连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--配置连接数据库的基本信息--&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test_mybatis?useUnicode=true&amp;amp;character=UTF-8&amp;amp;serverTimezone=UTC\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"li980616\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 通过Mapper代理实现自定义接口 自定义接口 1234567public interface UserRepository { public int save(User user); public int update(Integer id,User user); public int deleteById(Integer id); public List&lt;User&gt; findall(); public User findById(Integer id);} 创建接口对应的Mapper.xml，定义接口方法对应的Sql语句 statement标签可根据sql执行的业务选择insert，delete，update，select Mybatis框架会根据规则自动创建接口实现类的代理对象。 规则： XXXMapper.xml中namespace为接口的全类名 XXXMapper.xml中statement的id为接口中对应的方法名 XXXMapper.xml中statement的parameterType和接口中对应方法的参数类型一致 XXXMapper.xml中statement的resultType和接口中对应的方法的返回值类型要一致 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.UserRepository\"&gt; &lt;!-- 插入数据--&gt; &lt;insert id=\"save\" parameterType=\"com.litao.entity.User\"&gt; insert into user(username,birthday,sex,address) values(#{username},#{birthday},#{sex},#{address}) &lt;/insert&gt; &lt;!-- 修改数据--&gt; &lt;update id=\"update\"&gt; update user set username=#{param2.username},birthday=#{param2.birthday},sex=#{param2.sex},address=#{param2.address} where id=#{param1} &lt;/update&gt; &lt;!--根据id删除数据--&gt; &lt;delete id=\"deleteById\" parameterType=\"Integer\"&gt; delete from user where id=#{id} &lt;/delete&gt; &lt;!--查询所有--&gt; &lt;select id=\"findall\" resultType=\"com.litao.entity.User\"&gt; select * from user &lt;/select&gt; &lt;!--根据id查询数据--&gt; &lt;select id=\"findById\" parameterType=\"Integer\" resultType=\"com.litao.entity.User\"&gt; select * from user where id=#{id} &lt;/select&gt;&lt;/mapper&gt; 注意事项 在Mybatis中把持久层的操作接口和映射文件也叫做 Mapper，所以UserRespository和UserMapper是一样的 上述操作和注意事项完成后，开发中无需再写接口的实现类 在Mybatis的主配置文件注册UserRepository.xml 123&lt;mappers&gt; &lt;mapper resource=\"com/litao/repository/UserRepository.xml\"/&gt;&lt;/mappers&gt;","link":"/2019/05/19/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B8%80/"},{"title":"Mybatis框架学习三","text":"Mysql ：8.0 逆向工程 MyBatis框架需要：实体类、自定义Mapper接口、Mapper.xml 传统的开发中上述的三个组件需要开发者手动创建，逆向工程可以帮助开发者自动创建这三个组件，减轻工作量，提高工作效率。 缺点： 只能执行一次，多次执行会多次创建实体类 当表结构发生改变时，需要删除已生成的资源，再重新生成 使用 MyBatis Generator，简称MBG，是一个专门为Mybatis框架开发者定制的代码生成器，可自动生成Mybatis框架所需的实体类、Mapper接口、Mapper.xml，支持基本的CRUD操作，但开发者仍需要自己来完成一些复杂的sql。 引入依赖 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.15&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 创建MBG配置文件generatorConfig.xml jdbcConnection 配置数据库连接信息 javaModelGenerator配置JavaBean的生成策略 sqlMapGenerator配置SQL映射文件生成策略 javaClientGenerator配置Mapper接口的生成策略 table配置目标数据表 (tableName : 表名, dominObjectName ：JavaBean类名) 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;context id=\"testTables\" targetRuntime=\"MyBatis3\"&gt; &lt;jdbcConnection driverClass=\"com.mysql.cj.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/test_mybatis?useUnicode=true&amp;amp;character=UTF-8&amp;amp;serverTimezone=UTC\" userId=\"root\" password=\"li980616\" &gt;&lt;/jdbcConnection&gt; &lt;javaModelGenerator targetPackage=\"com.litao.entity\" targetProject=\"./src/main/java\"&gt;&lt;/javaModelGenerator&gt; &lt;sqlMapGenerator targetPackage=\"com.litao.repository\" targetProject=\"./src/main/java\"&gt;&lt;/sqlMapGenerator&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.litao.repository\" targetProject=\"./src/main/java\"&gt;&lt;/javaClientGenerator&gt; &lt;table tableName=\"user\" domainObjectName=\"User\"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 创建Generator执行类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.exception.InvalidConfigurationException;import org.mybatis.generator.exception.XMLParserException;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.io.IOException;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;public class Main { public static void main(String[] args) { List&lt;String&gt; warings=new ArrayList&lt;String&gt;(); boolean overwrite=true; String genCig=\"/generatorConfig.xml\"; File configFile=new File(Main.class.getResource(genCig).getFile()); ConfigurationParser configurationParser=new ConfigurationParser(warings); Configuration configuration=null; try { configuration=configurationParser.parseConfiguration(configFile); } catch (IOException e) { e.printStackTrace(); } catch (XMLParserException e) { e.printStackTrace(); } DefaultShellCallback callback=new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator=null; try { myBatisGenerator=new MyBatisGenerator(configuration,callback,warings); } catch (InvalidConfigurationException e) { e.printStackTrace(); } try { myBatisGenerator.generate(null); } catch (SQLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (InterruptedException e) { e.printStackTrace(); } }} MyBatis延迟加载 概念 延迟加载也叫懒加载、惰性加载，使用延迟加载可以提高程序的运行效率，针对于数据持久层的操作，在某些特定的情况下去访问特定的数据库，在其他情况下可以不访问某些表，从一定程度上减少了Java应用与数据库的交互次数。 查询学生和班级时，学生和班级是两个不同的表，如果当前需求只需要获取学生的信息，那只需要查询学生的单表即可，如果需要通过学生获取对应的班级信息，则必须查询两个表。 不同的业务需求，需要查询不同的表，根据具体的业务需求来动态减少数据表查询的工作就是延迟加载。 将多表关联查询拆分成多个单表查询 StudentRepository.xml 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.StudentRepository\"&gt;&lt;resultMap id=\"studentMap\" type=\"com.litao.entity.Student\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"name\" property=\"name\"&gt;&lt;/result&gt; &lt;association property=\"classes\" javaType=\"com.litao.entity.Classes\" select=\"com.litao.repository.ClassesRepository.findById\" column=\"cid\"&gt; &lt;/association&gt;&lt;/resultMap&gt; &lt;select id=\"findById\" parameterType=\"long\" resultMap=\"studentMap\"&gt; select * from student where id=#{id} &lt;/select&gt;&lt;/mapper&gt; ClassesRepository.xml 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.ClassesRepository\"&gt; &lt;resultMap id=\"classesMap\" type=\"com.litao.entity.Classes\"&gt; &lt;id column=\"cid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"cname\" property=\"name\"&gt;&lt;/result&gt; &lt;collection property=\"students\" ofType=\"com.litao.entity.Student\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findById\" parameterType=\"long\" resultType=\"com.litao.entity.Classes\"&gt; select * from classes where id=#{id} &lt;/select&gt;&lt;/mapper&gt; 开启延迟加载（Mybatis主配置文件中添加） 123456&lt;settings&gt; &lt;!-- 打印sql--&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;!--开启延迟加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt;&lt;/settings&gt; 对比 未开启延迟加载： 只查询学生的名字时，我们只需要查询student表即可完成，但实际上依然会同时查询student和classes两种表 开启延迟加载： 之查询学生名字时，只用查询student表，而不会再联动查询classes表 Mybatis缓存 什么是Mybatis缓存 使用缓存可以减少Java应用与数据库的交互次数，从而提升程序的运行效率。如查询出id=1的对象，第一次查询之后会自动将该对象保存到缓存中，当下一次查询时，直接从缓存中取出对象即可，无需再次访问数据库。 缓存分类 一级缓存：SqlSession级别，默认开启，并且不能关闭。 操作数据库时需要创建SqlSession对象，在对象中有一个HashMap用于存储缓存数据，不同的SqlSession之间缓存数据区域是互不影响的。 一级缓存的作用域是SqlSession范围的，当在同一个SqlSession中执行两次相同的Sql语句时，第一次执行完毕后会将结果保存到缓存中，第二次查询时直接从缓存中获取。 注意：如果SqlSession执行了DML操作（insert、update、delete），MyBatis必须将缓存清空以保证数据的准确性。 1234567891011121314public class Test01 { public static void main(String[] args) { InputStream inputStream=Test01.class.getClassLoader().getResourceAsStream(\"Config.xml\"); SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory=builder.build(inputStream); SqlSession sqlSession=sqlSessionFactory.openSession(); StudentRepository studentRepository=sqlSession.getMapper(StudentRepository.class); Student student=studentRepository.findById(2); System.out.println(student.getName()); Student student1=studentRepository.findById(2); System.out.println(student1.getName()); }} 结果: 查询结果有两个，但SQL语句只执行了一次 Mapper级别，默认关闭，可以开启 使用二级缓存时，多个SqlSession使用同一个Mapper的Sql语句操作数据库时，得到的数据会存在二级缓存区，同样是使用HashMap进行数据存储，相当于一级缓存，二级缓存的范围更大，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。 二级缓存是多个SqlSession共享的，其作用域是Mapper的同一个namespace，不同的SqlSession两次执行相同的namespace下的Sql语句，参数也相同，则第一次执行成功之后会将数据保存到二级缓存中，第二次可直接从二级缓存中取出数据。 MyBatis自带的二级缓存 在MyBatis主配置文件中（Config.xml）开启二级缓存 12345678&lt;settings&gt; &lt;!-- 打印sql--&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;!--开启延迟加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!--开启二级缓存--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;&lt;/settings&gt; Mapper.xml中配置二级缓存 1&lt;cache&gt;&lt;/cache&gt; 实体类实现序列化接口 1public class Student implements Serializable 测试 12345678910111213141516public class Test01 { public static void main(String[] args) { InputStream inputStream=Test01.class.getClassLoader().getResourceAsStream(\"Config.xml\"); SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory=builder.build(inputStream); SqlSession sqlSession=sqlSessionFactory.openSession(); StudentRepository studentRepository=sqlSession.getMapper(StudentRepository.class); Student student=studentRepository.findById(2); System.out.println(student.getName()); sqlSession.close(); //把sqlSession关闭，进行二级缓存测试 sqlSession=sqlSessionFactory.openSession(); studentRepository=sqlSession.getMapper(StudentRepository.class); Student student1=studentRepository.findById(2); System.out.println(student1.getName()); }} 测试结果： ehcache二级缓存 在pom.xml中添加依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache-core&lt;/artifactId&gt;&lt;version&gt;2.4.3&lt;/version&gt;&lt;/dependency&gt; 在resources文件夹下添加ehcache.xml 1234567891011121314&lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"../config/ehcache.xsd\"&gt; &lt;diskStore/&gt; &lt;defaultCache maxElementsInMemory=\"1000\" maxElementsOnDisk=\"10000000\" eternal=\"false\" overflowToDisk=\"false\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"120\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\"&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt; 在MyBatis主配置文件中（Config.xml）开启二级缓存 12345678&lt;settings&gt; &lt;!-- 打印sql--&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;!--开启延迟加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!--开启二级缓存--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;&lt;/settings&gt; Mapper.xml中配置二级缓存 12345678&lt;cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"&gt; &lt;!--缓存创建之后，最后一次访问缓存的时间至缓存失效的时间间隔--&gt; &lt;property name=\"timeToIdleSeconds\" value=\"3600\"/&gt; &lt;!--缓存自创建时间起至失效的时间间隔--&gt; &lt;property name=\"timeToLiveSeconds\" value=\"3600\"/&gt; &lt;!--缓存回收策略，LRU表示移除近期使用最少的对象--&gt; &lt;property name=\"memoryStoreEvictionPolicy\" value=\"LRU\"/&gt;&lt;/cache&gt; MyBatis动态SQL 程序可以自动根据业务参数来决定SQL的组成。 if标签 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.AccountRepository\"&gt; &lt;select id=\"findByAccount\" parameterType=\"com.litao.entity.Account\" resultType=\"com.litao.entity.Account\"&gt; select * from account where &lt;if test=\"id!=null\"&gt; id=#{id} &lt;/if&gt; &lt;if test=\"username!=null\"&gt; and username=#{username} &lt;/if&gt; &lt;if test=\"password!=null\"&gt; and password=#{password} &lt;/if&gt; &lt;/select&gt;&lt;/mapper&gt; if标签可以自动根据表达式的结果来决定是否将对应的语句添加到SQL中，如果条件不成立则不添加，如果条件成立则添加。 where标签 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.AccountRepository\"&gt; &lt;select id=\"findByAccount\" parameterType=\"com.litao.entity.Account\" resultType=\"com.litao.entity.Account\"&gt; select * from account &lt;where&gt; &lt;if test=\"id!=null\"&gt; id=#{id} &lt;/if&gt; &lt;if test=\"username!=null\"&gt; and username=#{username} &lt;/if&gt; &lt;if test=\"password!=null\"&gt; and password=#{password} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; where标签可以自动判断是否要删除语句块中的and关键字，如果检测到where直接跟and拼接，则自动删除and，通常情况下 if 和 where 结合起来使用。 choose、when标签 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.AccountRepository\"&gt; &lt;select id=\"findByAccount\" parameterType=\"com.litao.entity.Account\" resultType=\"com.litao.entity.Account\"&gt; select * from account &lt;where&gt; &lt;choose&gt; &lt;when test=\"id!=null\"&gt; id=#{id} &lt;/when&gt; &lt;when test=\"username!=null\"&gt; username=#{username} &lt;/when&gt; &lt;when test=\"password\"&gt; password=#{password} &lt;/when&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; trim标签 trim标签中的prefix和suffix属性会被用来生成实际的SQL语句，会和标签内部的语句进行拼接，如果语句前后出现了prefixOverrides或者suffixOverrides属性中指定的值，MyBatis框架会自动将其删除。 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.AccountRepository\"&gt; &lt;select id=\"findByAccount\" parameterType=\"com.litao.entity.Account\" resultType=\"com.litao.entity.Account\"&gt; select * from account &lt;trim prefix=\"where\" prefixOverrides=\"and\"&gt; &lt;if test=\"id!=null\"&gt; id=#{id} &lt;/if&gt; &lt;if test=\"username!=null\"&gt; and username=#{username} &lt;/if&gt; &lt;if test=\"password!=null\"&gt; and password=#{password} &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt;&lt;/mapper&gt; set 标签 set标签用于update操作，会自动根据参数选择生成SQL语句。 123456789101112131415&lt;update id=\"update\" parameterType=\"com.litao.entity.Account\"&gt; update account &lt;set&gt; &lt;if test=\"id!=null\"&gt; id=#{id}, &lt;/if&gt; &lt;if test=\"username!=null\"&gt; username=#{username}, &lt;/if&gt; &lt;if test=\"password!=null\"&gt; password!=#{password} &lt;/if&gt; where id=#{id} &lt;/set&gt;&lt;/update&gt; foreach标签 foreach 标签可以迭代生成一系列值，这个标签主要用于SQL的in语句 1234567891011&lt;select id=\"findByIds\" parameterType=\"com.litao.entity.Account\"resultType=\"com.litao.entity.Account\"&gt; select * from account &lt;where&gt; &lt;foreach collection=\"ids\" open=\"id in (\" close=\")\" item=\"id\" separator=\",\"&gt; #{id} &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt;//select * from account where id in (?,?,?...);","link":"/2019/05/19/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B8%89/"},{"title":"MyBatis框架学习二","text":"mysql ：8.0 入门案例 读取配置文件 创建SqlSessionFactory工厂 创建工厂mybatis使用了构建者模式（把对象的创建细节隐藏，让使用者直接调用方法即可拿到对象） 使用工厂生产SqlSession对象 生产SqlSession使用了工厂模式（解耦，即降低类之间的依赖关系） 使用SqlSession创建接口的代理对象 session.getMapper(Class type); 创建接口实现类使用了代理模式（不修改源码的基础上对已有方法增强） 使用代理对象执行方法 释放资源 注意事项：不要忘记在映射配置中告诉mybatis要把数据封装到哪个实体类中（设定resultType的值为全类名） 查询所有操作 123456789101112131415161718192021222324252627282930313233/*mybatis 入门案例 */public class MybatisTest { public static void main(String[] args) { //1. 读取配置文件 try { InputStream in= Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2. 创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder(); SqlSessionFactory factory=builder.build(in); //3. 使用工厂生产SqlSession对象 SqlSession session=factory.openSession(); //4. 使用SqlSession创建接口的代理对象 UserRepository userRepository=session.getMapper(UserRepository.class); //5. 使用代理对象执行方法 List&lt;User&gt; users=userRepository.findall(); for(User user:users){ System.out.println(user); } //6. 释放资源 session.close(); in.close(); } catch (IOException e) { e.printStackTrace(); } }} 测试结果： 查询操作代码大致分析 读取配置文件 解析xml ：dom4j selectList方法 根据配置文件的信息创建Connection对象（注册驱动，获取连接） 获取预处理对象PreparedStatement connection.preparedStatement(sql) 执行查询sql语句，返回ResultSet ResultSet resultSet =preparedStatement.executeQuery(); 遍历结构集 resultSet 用于封装 List list =new ArrayList(); while(resultSet.next(){ E element =(E) Class.forName(“全限定类名”).newInstance ()（对应xml中的resultType） 封装:把每个内容添加到element中，再把element加入到list中 根据反射的方式来根据名称获取属性并赋值 list.add(element); } 返回list return list； 执行上述方法需要提供两个信息： 连接信息（用来创建connection） 映射信息：sql语句和封装结果的实体类全限定名（resultType），把这两个信息组合起来定义成一个对象（Map） String Mapper（映射） com.litao.repository.UserRepository String ClassPath findall string sql 根据接口的字节码创建代理对象 public T getMapper(Class type){ /* 类加载器：它使用的和被代理的对象是相同的类加载器 代理对象要实现的接口：在被代理对象实现相同的接口 代理方式：它就是增强的方法，需要自己来提供。此处是InnvocationHandler的接口，需要写一个该接口的实现类，在实现类中调用selectList方法 */ Proxy.newProxyInstance（类加载器，代理对象要实现的接口字节码数组，代理方式） } 这个让我想到了Spring框架中的AOP（面向切面编程）中的代理方式 通过id查询操作 12User user=userRepository.findById(3);System.out.println(user); 查询结果： 通过id删除 123User user=new User(21412,\"小黄\",simpleDateFormat.parse(\"2017-07-15 15:00:05\"),\"女\",\"上海浦东新区\");userRepository.update(22,user);sqlSession.commit(); 修改操作 123User user=new User(21412,\"小黄\",simpleDateFormat.parse(\"2017-07-15 15:00:05\"),\"女\",\"上海浦东新区\");userRepository.update(22,user);sqlSession.commit(); 插入操作 这里使用的是Mybatis原生接口执行添加操作，但不推荐使用原生接口 为实体类创建对应的Mapper.xml,定义管理对象数据的SQL 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.Mapper.UserMapper\"&gt; &lt;!--添加数据--&gt; &lt;insert id=\"save\" parameterType=\"com.litao.entity.User\"&gt; insert into user(username,birthday,sex,address) values(#{username},#{birthday},#{sex},#{address}) &lt;/insert&gt;&lt;/mapper&gt; namespace 通常设置为文件所在包+文件名的形式 insert 标签表示执行添加操作 select 标签表示执行查询操作 update 标签表示更新操作 delete 标签表示删除操作 id 是实际调用Mybatis 方法时需要用到的参数 parameterType 是调用对应方法时参数的数据类型 在全局配置文件中注册UserMapper.xml 123&lt;mappers&gt; &lt;mapper resource=\"com/litao/Mapper/UserMapper.xml\"/&gt;&lt;/mappers&gt; 测试 12345678910111213141516171819202122public class Test { public static void main(String[] args) throws IOException{// InputStream inputStream=Test.class.getClassLoader().getResourceAsStream(\"SqlMapConfig.xml\"); InputStream inputStream= Resources.getResourceAsStream(\"SqlMapConfig.xml\"); SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory=builder.build(inputStream); SqlSession sqlSession=sqlSessionFactory.openSession(); String statement=\"com.litao.Mapper.UserMapper.save\"; SimpleDateFormat simpleDateFormat=new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\"); try { User user=new User(5,\"小红\",simpleDateFormat.parse(\"2017-07-15 15:00:05\"),\"女\",\"上海\"); sqlSession.insert(statement,user); sqlSession.commit(); sqlSession.close(); inputStream.close(); } catch (ParseException e) { e.printStackTrace(); }catch (IOException e){ e.printStackTrace(); } }} 级联查询 实体类： 12345678import lombok.Data;@Datapublic class Student { private long id; private String name; private Classes classes;} 12345678910import lombok.Data;import java.util.List;@Datapublic class Classes { private long id; private String name; private List&lt;Student&gt; students;} 一对一（一个学生对应一个班级） StudentRepository 12345import com.litao.entity.Student;public interface StudentRepository { public Student findById(long id);} StudentRepository.xml 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.StudentRepository\"&gt;&lt;resultMap id=\"studentMap\" type=\"com.litao.entity.Student\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"name\" property=\"name\"&gt;&lt;/result&gt; &lt;association property=\"classes\" javaType=\"com.litao.entity.Classes\"&gt; &lt;id column=\"cid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"cname\" property=\"name\"&gt;&lt;/result&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"findById\" parameterType=\"long\" resultMap=\"studentMap\"&gt; select s.id,s.name,c.id as cid,c.name as cname from student s,classes cwhere s.id = #{id} and s.cid = c.id &lt;/select&gt;&lt;/mapper&gt; 测试结果： Student(id=2, name=李四, classes=Classes(id=2, name=6班, students=null)) 一对多（一个班级对应多个学生） ClassesRepository 12345import com.litao.entity.Classes;public interface ClassesRepository { public Classes findById(long id);} ClassesRepository.xml 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.ClassesRepository\"&gt; &lt;resultMap id=\"classesMap\" type=\"com.litao.entity.Classes\"&gt; &lt;id column=\"cid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"cname\" property=\"name\"&gt;&lt;/result&gt; &lt;collection property=\"students\" ofType=\"com.litao.entity.Student\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findById\" parameterType=\"long\" resultMap=\"classesMap\"&gt; select s.id,s.name,c.id as cid,c.name as cname from student s,classes cwhere c.id = #{id} and s.cid = c.id &lt;/select&gt;&lt;/mapper&gt; 测试结果： Classes(id=2, name=6班, students=[Student(id=1, name=张三, classes=null), Student(id=2, name=李四, classes=null), Student(id=3, name=王五, classes=null)] ) 多对多 多对多即由多个一对多组成","link":"/2019/05/19/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%BA%8C/"},{"title":"Intellij IDEA 安装","text":"操作系统: win10 1.IDEA介绍 IDEA全称IntelliJ IDEA（JetBrains公司旗下的产品），是Java编程语言开发的集成境。“Capable and Ergonomic IDE for JVM” 官网,适用于JVM的功能强大且符合人体工程学(Human Engineering)的IDE（Integrated Development Environment-集成开发环境） 2. 下载并安装 网址 : https://www.jetbrains.com/idea/ 进行安装 ​ 一直点击next完成安装 3.目录结构 bin:容器，执行文件和启动参数等 help：快捷键文档和其它帮助文档 jbr:??? lib:IDEA依赖的类库 license：各个插件许可 plugins: IDEA插件 redist:??? bin目录下： idea.properties :IDEA配置文件 idea64.exe.vmoptions ：64位idea vm配置文件 vm配置文件 -Xms128m : 设置初始的内存数，提高该值可以加快Java程序的启动速度（16内存好像可以尝试改为-Xms512m） -Xmx1010m :设置最大内存数，提高该值，可以减少内存Garage收集的频率，提高程序性能（16内存好像可以尝试改为-Xmx1500m） -XX:ReservedCodeCacheSize=240m ：保留代码占用的内存容量（16G 内存的机器可尝试设置为500m） 设置目录（C盘用户文件下） 这是IDEA保存各种配置的目录。 这个设置目录有一个特性，就是你删除掉整个目录之 后，重新启动 IntelliJ IDEA 会再自动帮你生成一个全新的默认配置，所以很多时候如果你把 IntelliJ IDEA 配置改乱了，只要删掉该目录，一切都会还原到默认。 有两个是因为我下过两个版本的IDEA，老版本的配置我没有删掉 config：该目录是IDEA 个性化化配置目录，或者说是整个 IDE 设置目录。安装新版本的 IntelliJ IDEA 时会自动扫描硬盘上的旧配置目录，被扫描的目录指的就是该目录。这个目录主要记录了IDEA 主要配置功能、自定义的代码模板、自定义的文件模板、自定义的快捷键、 Project 的 tasks 记录等个性化的设置。 system : 该目录是IDEA系统文件目录，是 IDEA 与开发项目一个桥梁目录，里面主要有：缓存、索引、容器文件输出等 4. 这里推荐一款IDEA编辑字体(jetbrains mono) 字体样例: 下载步骤 官方网址: https://www.jetbrains.com/lp/mono/ 点击 右上角下载 下载完成后，解压，进入ttf文件夹 逐一双击进行安装 字体样式安装完后，打开IDEA，依次进入file ----&gt;Settings —&gt;Editor ----&gt;Font 进行设置","link":"/2020/02/17/Intellij-IDEA-%E5%AE%89%E8%A3%85/"},{"title":"DataGrip连接Mysql错误之时区错误","text":"操作系统: win 10 Mysql 版本 : 8.0 错误描述 在DataGrip中连接Mysql时，发生如下错误: 原因:在使用Mysql的6.0.x以上的jar的时候，需要指定serverTimezone,否则就会出现异常。 解决方法 方法一：命令行登录MySql修改Mysql 时区 这种方法不推荐，因为当Mysql服务重启的时候，被修改的时区时间会被重置，下次连接Mysql时问 题依然会存在。 配置Mysql环境变量 编辑Path，加入Mysql的bin路径 命令行登录Mysql mysql -u root -p '你的密码' 查看并修改时区 show variables like ``'%time_zone%'; ​ Mysql默认SYSTEM是美国时间，比我国晚8个小时 ​ set global time_zone = ``'+8:00'``; ​ 修改后，重新用DataGrip重新连接，问题解决。 方法二: 修改database配置中的serverTimezone 设置serverTimezone 为UTC (世界协调时间) 再次连接 使用IDEA内置的数据库管理工具时，如果遇到时区问题，也可用这种方法解决","link":"/2019/05/16/DataGrip%E8%BF%9E%E6%8E%A5Mysql%E9%94%99%E8%AF%AF%E4%B9%8B%E6%97%B6%E5%8C%BA%E9%94%99%E8%AF%AF/"}],"tags":[{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"Mysql","slug":"Mysql","link":"/tags/Mysql/"},{"name":"MyBatis","slug":"MyBatis","link":"/tags/MyBatis/"}],"categories":[{"name":"Java Web","slug":"Java-Web","link":"/categories/Java-Web/"}]}
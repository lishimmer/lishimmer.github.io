{"pages":[{"title":"about","text":"个人博客，仅供学习","link":"/about/index.html"}],"posts":[{"title":"DataGrip连接Mysql错误之时区错误","text":"操作系统: win 10 Mysql 版本 : 8.0 错误描述 在DataGrip中连接Mysql时，发生如下错误: 原因:在使用Mysql的6.0.x以上的jar的时候，需要指定serverTimezone,否则就会出现异常。 解决方法 方法一：命令行登录MySql修改Mysql 时区 这种方法不推荐，因为当Mysql服务重启的时候，被修改的时区时间会被重置，下次连接Mysql时问 题依然会存在。 配置Mysql环境变量 编辑Path，加入Mysql的bin路径 命令行登录Mysql mysql -u root -p '你的密码' 查看并修改时区 show variables like ``'%time_zone%'; ​ Mysql默认SYSTEM是美国时间，比我国晚8个小时 ​ set global time_zone = ``'+8:00'``; ​ 修改后，重新用DataGrip重新连接，问题解决。 方法二: 修改database配置中的serverTimezone 设置serverTimezone 为UTC (世界协调时间) 再次连接 使用IDEA内置的数据库管理工具时，如果遇到时区问题，也可用这种方法解决","link":"/2019/05/16/DataGrip%E8%BF%9E%E6%8E%A5Mysql%E9%94%99%E8%AF%AF%E4%B9%8B%E6%97%B6%E5%8C%BA%E9%94%99%E8%AF%AF/"},{"title":"Git命令行（包括一些linux命令行）","text":"linux 命令行 ll 查看当前文件夹所有文件 ll | less 查看根目录文件 （ ESC + :wq 或者 ESC + ZZ 退出） ls -1A 查看当前文件夹中包括隐藏文件的所有文件 ls -1A | less 查看当前文件夹中包括隐藏文件的根目录文件 mkdir &lt;文件夹名&gt; 创建文件夹 vim &lt;file&gt; 利用vim文本编辑器创建文件 cat &lt;file&gt; 查看文件中的内容 tail &lt;file&gt; 查看文件内容 -f 循环读取 常用于查阅正在改变的日志文件 -n &lt;行数&gt; 显示文件尾部n行内容 pwd 当前的文件全路径名 cd ~ 进入家目录 rm -r 只能删除文件，不能删除文件夹 rm -R 既能删除文件也能删除文件夹 本地库操作 git help &lt;命令&gt; 查看命令帮助文档 git init 初始化一个本地仓库 git config --global user.name 设置系统级别的签名 git config --global user.email 设置系统级别的签名 git status 查看工作区与暂存区的状态 git add &lt;file&gt; 把文件添加到暂存区 暂存区为工作区下隐藏文件 .git中的index文件 git rm --cached &lt;file&gt; 把文件从暂存区中移除 git commit -m&quot;commit message&quot; &lt;file&gt; 把暂存区中 每次 commit 都为生成一个commit id（哈希值），方便以后查看历史版本 未追踪的文件必须先git add 再 git commit，已追踪的文件可以直接 git commit -m&quot;commit message&quot; -a（文件修改） 工作区（写代码）----》暂存区（临时存储） --------》 本地库（历史版本） git log 查看历史版本 git log --prtty=oneline 每个版本只显示一条信息 git log --oneline 只显示一部分哈希值 git reflog 历史版本好像是存储在.git 中的 object文件夹下 版本前进、后退 HEAD指针的移动 git reset --hard &lt;局部哈希值&gt; 前期或后退到某个版本 git reset --hard HEAD^ 后退一个版本 git reset --hard HEAD~3 后退3个版本 –soft 参数 ：仅仅在本地仓库移动HEAD指针 –mixed 参数：在本地库移动HEAD指针并且重置暂存区 –hard 参数：在本地库移动HEAD指针并且重置暂存区和工作区 文件删除 git rm &lt;file&gt; 从工作区和暂存区删除文件 git reset --hard HEAD 工作区和暂存区恢复刚刚删除的文件 执行git commit &lt;file&gt; 提交到版本库 git diff &lt;file&gt; 将工作区中的文件和暂存区中的文件进行比较 git diff &lt;本地库中的历史版本&gt; &lt;file&gt; 将工作区中的文件与本地库历史记录中的文件进行比较 git diff HEAD 比较当前工作区中的多个文件 分支管理 分支：在版本控制过程中，使用多条线同时推进多个任务 本质：创建和移动HEAD指针 优点： 同时并行推进多个功能开发，提高开发效率 各个分支在开发过程中，如果某一个分支开发失败，不会对其它分支有任何影响，失败的分支删除重新开始即可 git branch -v 查看分支 git branch &lt;分支名&gt; 创建一个分支 git checkout &lt;分支名&gt; 切换分支 git merge [分支名] 合并分支名（注意：要先切换到要合并到的分支（如master）） 解决冲突： 编辑文件，删除特殊符号 把文件修改到满意的程度，保存退出 git add git commit -m&quot;日志信息&quot; （此时commit一定不能带具体的文件名） 远程库操作（使用Github作为案例） 个人开发者或企业使用GitLab较多，因为github默认会将代码公开出去 git remote add &lt;别名&gt; &lt;远程仓库地址&gt; 添加远程仓库地址 git remote -v 查看远程仓库地址 git push &lt;别名&gt; &lt;分支名&gt; 把本地仓库推送到远程仓库 注意：如果组长有一个仓库，成员要想推送内容到组长的仓库，必须先收到组长的加入请求。 组长在本地仓库的settings --》Manage accesss —》Invite a collaborator 通过成员github注册邮箱进行邀请 成员接收邀请 注意：如果不是基于Github远程库的最新版所作的修改，则不能被推送，必须先执行拉取操作（Github 貌似会根据hashcode是否一致来判断本地库与远程最新版中的内容是否一致） git clone &lt;远程仓库地址&gt; 作用： 完整地把远程库下载到本地 创建远程仓库地址别名 初始化本地库（生成.git） 拉取 git pull &lt;远程仓库别名&gt; &lt;远程仓库分支名&gt; pull 操作等于fetch + merge git fetch &lt;远程仓库地址别名&gt; &lt;远程仓库分支名&gt; git merge &lt;远程仓库地址别名/远程仓库分支名&gt; fork （解决跨团队协作问题） 克隆一份其他人的仓库到自己的github仓库 拉取到本地 本地修改，然后推送到远程 GitHub上创建 Pull Request 仓库主人可以查看 Pull Request 并审核代码 ，考虑是否合并代码，还可以与Pull Request 的发起人聊天对话，商讨代码（不愧是最大的同性交友网站） ssh （用来免密登录） ssh-keygen -t rsa -C &lt;github注册邮箱地址&gt; 生成ssh（安全外壳协议） 复制家目录（cd ~）下 .ssh 文件夹中的 id_rsa.pub 文件内容 Github —》头像—》settings—》SSH and GPG keys —》 new SSH key 输入密钥内容 使用： 复制仓库的ssh地址 创建远程仓库别名（git remote add）","link":"/2020/01/16/Git%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"title":"IDEA 插件","text":"插件下载地址 https://plugins.jetbrains.com/ 注意IDEA版本兼容 IDEA自带的markplace Github中搜索插件名 CodeGlance 代码编辑区迷你缩放图 Lombok 通过注解来完成set、get、tostring方法的编写，也可生成无参构造函数和全参数的构造函数。 注意：使用时需要添加依赖 Background Image Plus 自定义IDEA 背景图 TranslationPlugin 语言翻译 Rainbow Brackets 以不同颜色显示成对括号 Grep Console 自定义控制台日志输出信息颜色 Statistic 统计有多少行代码、多少注释等信息 RestfulToolkit controller层接口查找 GsonFormat Json转Java 类 Mybatis Log Plugin 打印具体的sql语句 Free Mybatis plugin 实现mybatis中xml 方法id与接口之间的跳转 Maven Helpler 更好地进行依赖管理，例如可以解决依赖冲突 Alibaba Java Coding Guidelines 阿里巴巴开发规范 SonarLint 帮助扫描代码的问题，例如 性能，安全和重复问题，显著提升代码质量 Easy Code 根据数据库表生成JavaBean Material Theme UI IDEA 界面美化 Key Promoter X 快捷键提示 JRebel for IntelliJ Java Web项目热部署 .ignore 生成git ignore文件","link":"/2020/02/18/IDEA-%E6%8F%92%E4%BB%B6/"},{"title":"IDEA中lombok插件离线安装","text":"因为网络问题，安装lombok一直失败，所以这次采用插件包离线安装 下载插件包，插件包有两个地方可以下载，分别是IDEA的官方插件仓库和GitHub里lombok-intellij-plugin仓库 IDEA：http://plugins.jetbrains.com/plugin/6317-lombok-plugin Github：https://github.com/mplushnikov/lombok-intellij-plugin/releases 我这里采用Github仓库的 对照自己下载的IDEA版本下载指定的插件包 文件下载 不清楚自己IDEA的，可依次进入IDEA-----&gt; Help —&gt;About查看 安装插件包 依次进入IDEA —&gt; Settings -----&gt;Plugins 点击第三个选项，找到刚才下载的lombok插件包的位置进行安装，完成后重启IDEA 这样就安装完成了 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt;&lt;/dependency&gt;","link":"/2020/02/17/IDEA%E4%B8%ADlombok%E6%8F%92%E4%BB%B6%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85/"},{"title":"Intellij IDEA 安装","text":"操作系统: win10 1.IDEA介绍 IDEA全称IntelliJ IDEA（JetBrains公司旗下的产品），是Java编程语言开发的集成境。“Capable and Ergonomic IDE for JVM” 官网,适用于JVM的功能强大且符合人体工程学(Human Engineering)的IDE（Integrated Development Environment-集成开发环境） 2. 下载并安装 网址 : https://www.jetbrains.com/idea/ 进行安装 ​ 一直点击next完成安装 3.目录结构 bin:容器，执行文件和启动参数等 help：快捷键文档和其它帮助文档 jbr:??? lib:IDEA依赖的类库 license：各个插件许可 plugins: IDEA插件 redist:??? bin目录下： idea.properties :IDEA配置文件 idea64.exe.vmoptions ：64位idea vm配置文件 vm配置文件 -Xms128m : 设置初始的内存数，提高该值可以加快Java程序的启动速度（16内存好像可以尝试改为-Xms512m） -Xmx1010m :设置最大内存数，提高该值，可以减少内存Garage收集的频率，提高程序性能（16内存好像可以尝试改为-Xmx1500m） -XX:ReservedCodeCacheSize=240m ：保留代码占用的内存容量（16G 内存的机器可尝试设置为500m） 设置目录（C盘用户文件下） 这是IDEA保存各种配置的目录。 这个设置目录有一个特性，就是你删除掉整个目录之后，重新启动 IntelliJ IDEA 会再自动帮你生成一个全新的默认配置，所以很多时候如果你把IntelliJ IDEA 配置改乱了，只要删掉该目录，一切都会还原到默认。 有两个是因为我下过两个版本的IDEA，老版本的配置我没有删掉 config：该目录是IDEA 个性化化配置目录，或者说是整个 IDE 设置目录。安装新版本的 IntelliJ IDEA 时会自动扫描硬盘上的旧配置目录，被扫描的目录指的就是该目录。这个目录主要记录了IDEA 主要配置功能、自定义的代码模板、自定义的文件模板、自定义的快捷键、 Project 的 tasks 记录等个性化的设置。 system : 该目录是IDEA系统文件目录，是 IDEA 与开发项目一个桥梁目录，里面主要有：缓存、索引、容器文件输出等 4. 这里推荐一款IDEA编辑字体(jetbrains mono) 字体样例: 下载步骤 官方网址: https://www.jetbrains.com/lp/mono/ 点击 右上角下载 下载完成后，解压，进入ttf文件夹 逐一双击进行安装 字体样式安装完后，打开IDEA，依次进入file ----&gt;Settings —&gt;Editor ----&gt;Font 进行设置","link":"/2020/02/17/Intellij-IDEA-%E5%AE%89%E8%A3%85/"},{"title":"JDBC学习","text":"概述 Java DataBase Connectivity 是一个独立于特定数据库的管理系统，通用的的SQL数据库存取和操作的公共接口。 定义了一组标准，为访问不同数据库提供了统一的途径。 JDBC体系结构 JDBC接口包含了两个层面: 面向应用的API，供程序员调用 面向数据库的API，供厂商开发数据库的驱动程序 JDBC API 提供者：Java官方 内容：供开发者调用的接口 java.sql 和 javax.sql DriverManager类 Connection接口 Statement 接口 ResultSet 接口 DriverManager 提供者：Java官方 作用：管理不同的JDBC驱动 JDBC 驱动 提供者：数据库厂商 作用：负责连接不同的数据库 JDBC开发流程 加载驱动（只需要加载一次） 建立数据库连接（Connection） 执行SQL语句（Statement） ResultSet接收结果集（查询） 断开连接，释放资源 使用 加载数据库驱动，Java程序和数据库之间的桥梁 获取Connection，Java程序与数据库的一次连接 创建Statement对象，由Connection产生，执行SQL语句 如果需要连接返回值，创建ResultSet对象，保存Statement执行之后所查询到的结果 123456789101112131415161718192021222324252627282930313233343536373839404142package com.litao.test;import java.sql.*;import java.util.Date;public class Test { public static void main(String[] args) { try { //加载驱动 Class.forName(\"com.mysql.cj.jdbc.Driver\"); //获取连接 String url = \"jdbc:mysql://localhost:3306/test? useUnicode=true&amp;characterEncoding=UTF-8\"; String user = \"root\"; String password = \"li980616\"; Connection connection = DriverManager.getConnection(url,user,password); // String sql = \"insert into student(name,score,birthday) values('李 四',78,'1999-01-01')\"; // String sql = \"update student set name = '李四'\"; // String sql = \"delete from student\"; // Statement statement = connection.createStatement(); // int result = statement.executeUpdate(sql); String sql = \"select * from student\"; Statement statement = connection.createStatement(); ResultSet resultSet = statement.executeQuery(sql); while (resultSet.next()){ Integer id = resultSet.getInt(\"id\"); String name = resultSet.getString(2); Double score = resultSet.getDouble(3); Date date = resultSet.getDate(4); System.out.println(id+\"-\"+name+\"-\"+score+\"-\"+date); } resultset.close(); connection.close(); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e){ e.printStackTrace(); } }} PreparedStatement Statement 的子类，提供了SQL占位符的功能 为何使用PreparedStatement 使用Statement进行开发有两个问题： 需要频繁拼接String 字符串，出错率高 存在SQL注入的风险 SQL注入：利用某些系统没有对用户输入的信息进行充分的检测，在用户输入的数据中注入非法的SQL语句，从而利用系统的SQL引擎完成恶意行为的做法。如 1select * from student where username='张三' or '1'='1' 使用 12345678910111213141516171819202122232425String url = \"jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8\";String user = \"root\";String password = \"li980616\";Connection connection = DriverManager.getConnection(url,user,password);String username = \"李四\";String mypassword = \"123\";String sql = \"select * from t_user where username = ? and password = ?\";System.out.println(sql);PreparedStatement preparedStatement = connection.prepareStatement(sql);preparedStatement.setString(1,username);preparedStatement.setString(2,mypassword);ResultSet resultSet = preparedStatement.executeQuery();if(resultSet.next()){ System.out.println(\"登录成功\");}else{ System.out.println(\"登录失败\");}resultset.close();connection.close();} catch (ClassNotFoundException e) { e.printStackTrace();} catch (SQLException e){ e.printStackTrace();}","link":"/2019/02/21/JDBC%E5%AD%A6%E4%B9%A0/"},{"title":"MyBatis框架学习一","text":"mysql : 8.0 概述 持久层技术解决方案： JDBC技术： Connection PreparedStatement ResultSet Spring的JdbcTemplate: Spring中对jdbc的封装 Apache的DButils： 与Spring的JdbcTemplate很像，也是对Jdbc的封装 以上这些都不是框架，JDBC是规范，Spring的JdbcTemplate和Apache的DButils都只是工具类 MyBatis框架概述： Mybatis是apache的一个开源项目iBatis，2010年这个项目由apache software foundation迁移到了google code，并且改名为Mybatis，2013年迁移到Github Mybatis是一个数据持久化的开源框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建链接、创建statement等过程。 mybatis可通过xml或注解的方式将要执行的statement语句配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。 采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，是我们不用与Jdbc api打交道，就可以完成对数据库的持久化操作。 创建Mysql用户测试表 12345678create table user( id int(10) not null auto_increment, username varchar(30) not null comment '用户名称', birthday datetime default null comment '生日', sex char(1) default null comment '性别', address varchar(100) default null comment '地址', primary key (id))ENGINE =InnoDB DEFAULT CHARSET =utf8; 插入数据 环境配置 导入依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.15&lt;/version&gt;&lt;/dependency&gt; 创建实体类的接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.io.Serializable;import java.util.Date;public class User implements Serializable { private static final long serialVersionUID=1L; private Integer id; private String username; private Date birthday; private String sex; private String address; public static long getSerialVersionUID() { return serialVersionUID; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Date getBirthday() { return birthday; } public void setBirthday(Date birthday) { this.birthday = birthday; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public User(Integer id, String username, Date birthday, String sex, String address) { this.id = id; this.username = username; this.birthday = birthday; this.sex = sex; this.address = address; } public User() { } @Override public String toString() { return \"User{\" + \"id=\" + id + \", username='\" + username + '\\'' + \", birthday=\" + birthday + \", sex='\" + sex + '\\'' + \", address='\" + address + '\\'' + '}'; }} 在resource文件下创建Mybatis的主配置文件 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!--mybatis主配置文件--&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default=\"mysql\"&gt; &lt;!--配置mysql的环境--&gt; &lt;environment id=\"mysql\"&gt; &lt;!--配置事务的类型--&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!--配置连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--配置连接数据库的基本信息--&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test_mybatis?useUnicode=true&amp;amp;character=UTF-8&amp;amp;serverTimezone=UTC\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"li980616\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 通过Mapper代理实现自定义接口 自定义接口 1234567public interface UserRepository { public int save(User user); public int update(Integer id,User user); public int deleteById(Integer id); public List&lt;User&gt; findall(); public User findById(Integer id);} 创建接口对应的Mapper.xml，定义接口方法对应的Sql语句 statement标签可根据sql执行的业务选择insert，delete，update，select Mybatis框架会根据规则自动创建接口实现类的代理对象。 规则： XXXMapper.xml中namespace为接口的全类名 XXXMapper.xml中statement的id为接口中对应的方法名 XXXMapper.xml中statement的parameterType和接口中对应方法的参数类型一致 XXXMapper.xml中statement的resultType和接口中对应的方法的返回值类型要一致 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.UserRepository\"&gt; &lt;!-- 插入数据--&gt; &lt;insert id=\"save\" parameterType=\"com.litao.entity.User\"&gt; insert into user(username,birthday,sex,address) values(#{username},#{birthday},#{sex},#{address}) &lt;/insert&gt; &lt;!-- 修改数据--&gt; &lt;update id=\"update\"&gt; update user set username=#{param2.username},birthday=#{param2.birthday},sex=#{param2.sex},address=#{param2.address} where id=#{param1} &lt;/update&gt; &lt;!--根据id删除数据--&gt; &lt;delete id=\"deleteById\" parameterType=\"Integer\"&gt; delete from user where id=#{id} &lt;/delete&gt; &lt;!--查询所有--&gt; &lt;select id=\"findall\" resultType=\"com.litao.entity.User\"&gt; select * from user &lt;/select&gt; &lt;!--根据id查询数据--&gt; &lt;select id=\"findById\" parameterType=\"Integer\" resultType=\"com.litao.entity.User\"&gt; select * from user where id=#{id} &lt;/select&gt;&lt;/mapper&gt; 注意事项 在Mybatis中把持久层的操作接口和映射文件也叫做 Mapper，所以UserRespository和UserMapper是一样的 上述操作和注意事项完成后，开发中无需再写接口的实现类 在Mybatis的主配置文件注册UserRepository.xml 123&lt;mappers&gt; &lt;mapper resource=\"com/litao/repository/UserRepository.xml\"/&gt;&lt;/mappers&gt;","link":"/2019/05/19/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B8%80/"},{"title":"Mybatis框架学习三","text":"Mysql ：8.0 逆向工程 MyBatis框架需要：实体类、自定义Mapper接口、Mapper.xml 传统的开发中上述的三个组件需要开发者手动创建，逆向工程可以帮助开发者自动创建这三个组件，减轻工作量，提高工作效率。 缺点： 只能执行一次，多次执行会多次创建实体类 当表结构发生改变时，需要删除已生成的资源，再重新生成 使用 MyBatis Generator，简称MBG，是一个专门为Mybatis框架开发者定制的代码生成器，可自动生成Mybatis框架所需的实体类、Mapper接口、Mapper.xml，支持基本的CRUD操作，但开发者仍需要自己来完成一些复杂的sql。 引入依赖 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.15&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 创建MBG配置文件generatorConfig.xml jdbcConnection 配置数据库连接信息 javaModelGenerator配置JavaBean的生成策略 sqlMapGenerator配置SQL映射文件生成策略 javaClientGenerator配置Mapper接口的生成策略 table配置目标数据表 (tableName : 表名, dominObjectName ：JavaBean类名) 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;context id=\"testTables\" targetRuntime=\"MyBatis3\"&gt; &lt;jdbcConnection driverClass=\"com.mysql.cj.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/test_mybatis?useUnicode=true&amp;amp;character=UTF-8&amp;amp;serverTimezone=UTC\" userId=\"root\" password=\"li980616\" &gt;&lt;/jdbcConnection&gt; &lt;javaModelGenerator targetPackage=\"com.litao.entity\" targetProject=\"./src/main/java\"&gt;&lt;/javaModelGenerator&gt; &lt;sqlMapGenerator targetPackage=\"com.litao.repository\" targetProject=\"./src/main/java\"&gt;&lt;/sqlMapGenerator&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.litao.repository\" targetProject=\"./src/main/java\"&gt;&lt;/javaClientGenerator&gt; &lt;table tableName=\"user\" domainObjectName=\"User\"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 创建Generator执行类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.exception.InvalidConfigurationException;import org.mybatis.generator.exception.XMLParserException;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.io.IOException;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;public class Main { public static void main(String[] args) { List&lt;String&gt; warings=new ArrayList&lt;String&gt;(); boolean overwrite=true; String genCig=\"/generatorConfig.xml\"; File configFile=new File(Main.class.getResource(genCig).getFile()); ConfigurationParser configurationParser=new ConfigurationParser(warings); Configuration configuration=null; try { configuration=configurationParser.parseConfiguration(configFile); } catch (IOException e) { e.printStackTrace(); } catch (XMLParserException e) { e.printStackTrace(); } DefaultShellCallback callback=new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator=null; try { myBatisGenerator=new MyBatisGenerator(configuration,callback,warings); } catch (InvalidConfigurationException e) { e.printStackTrace(); } try { myBatisGenerator.generate(null); } catch (SQLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (InterruptedException e) { e.printStackTrace(); } }} MyBatis延迟加载 概念 延迟加载也叫懒加载、惰性加载，使用延迟加载可以提高程序的运行效率，针对于数据持久层的操作，在某些特定的情况下去访问特定的数据库，在其他情况下可以不访问某些表，从一定程度上减少了Java应用与数据库的交互次数。 查询学生和班级时，学生和班级是两个不同的表，如果当前需求只需要获取学生的信息，那只需要查询学生的单表即可，如果需要通过学生获取对应的班级信息，则必须查询两个表。 不同的业务需求，需要查询不同的表，根据具体的业务需求来动态减少数据表查询的工作就是延迟加载。 将多表关联查询拆分成多个单表查询 StudentRepository.xml 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.StudentRepository\"&gt;&lt;resultMap id=\"studentMap\" type=\"com.litao.entity.Student\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"name\" property=\"name\"&gt;&lt;/result&gt; &lt;association property=\"classes\" javaType=\"com.litao.entity.Classes\" select=\"com.litao.repository.ClassesRepository.findById\" column=\"cid\"&gt; &lt;/association&gt;&lt;/resultMap&gt; &lt;select id=\"findById\" parameterType=\"long\" resultMap=\"studentMap\"&gt; select * from student where id=#{id} &lt;/select&gt;&lt;/mapper&gt; ClassesRepository.xml 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.ClassesRepository\"&gt; &lt;resultMap id=\"classesMap\" type=\"com.litao.entity.Classes\"&gt; &lt;id column=\"cid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"cname\" property=\"name\"&gt;&lt;/result&gt; &lt;collection property=\"students\" ofType=\"com.litao.entity.Student\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findById\" parameterType=\"long\" resultType=\"com.litao.entity.Classes\"&gt; select * from classes where id=#{id} &lt;/select&gt;&lt;/mapper&gt; 开启延迟加载（Mybatis主配置文件中添加） 123456&lt;settings&gt; &lt;!-- 打印sql--&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;!--开启延迟加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt;&lt;/settings&gt; 对比 未开启延迟加载： 只查询学生的名字时，我们只需要查询student表即可完成，但实际上依然会同时查询student和classes两种表 开启延迟加载： 之查询学生名字时，只用查询student表，而不会再联动查询classes表 Mybatis缓存 什么是Mybatis缓存 使用缓存可以减少Java应用与数据库的交互次数，从而提升程序的运行效率。如查询出id=1的对象，第一次查询之后会自动将该对象保存到缓存中，当下一次查询时，直接从缓存中取出对象即可，无需再次访问数据库。 缓存分类 一级缓存：SqlSession级别，默认开启，并且不能关闭。 操作数据库时需要创建SqlSession对象，在对象中有一个HashMap用于存储缓存数据，不同的SqlSession之间缓存数据区域是互不影响的。 一级缓存的作用域是SqlSession范围的，当在同一个SqlSession中执行两次相同的Sql语句时，第一次执行完毕后会将结果保存到缓存中，第二次查询时直接从缓存中获取。 注意：如果SqlSession执行了DML操作（insert、update、delete），MyBatis必须将缓存清空以保证数据的准确性。 1234567891011121314public class Test01 { public static void main(String[] args) { InputStream inputStream=Test01.class.getClassLoader().getResourceAsStream(\"Config.xml\"); SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory=builder.build(inputStream); SqlSession sqlSession=sqlSessionFactory.openSession(); StudentRepository studentRepository=sqlSession.getMapper(StudentRepository.class); Student student=studentRepository.findById(2); System.out.println(student.getName()); Student student1=studentRepository.findById(2); System.out.println(student1.getName()); }} 结果: 查询结果有两个，但SQL语句只执行了一次 Mapper级别，默认关闭，可以开启 使用二级缓存时，多个SqlSession使用同一个Mapper的Sql语句操作数据库时，得到的数据会存在二级缓存区，同样是使用HashMap进行数据存储，相当于一级缓存，二级缓存的范围更大，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。 二级缓存是多个SqlSession共享的，其作用域是Mapper的同一个namespace，不同的SqlSession两次执行相同的namespace下的Sql语句，参数也相同，则第一次执行成功之后会将数据保存到二级缓存中，第二次可直接从二级缓存中取出数据。 MyBatis自带的二级缓存 在MyBatis主配置文件中（Config.xml）开启二级缓存 12345678&lt;settings&gt; &lt;!-- 打印sql--&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;!--开启延迟加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!--开启二级缓存--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;&lt;/settings&gt; Mapper.xml中配置二级缓存 1&lt;cache&gt;&lt;/cache&gt; 实体类实现序列化接口 1public class Student implements Serializable 测试 12345678910111213141516public class Test01 { public static void main(String[] args) { InputStream inputStream=Test01.class.getClassLoader().getResourceAsStream(\"Config.xml\"); SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory=builder.build(inputStream); SqlSession sqlSession=sqlSessionFactory.openSession(); StudentRepository studentRepository=sqlSession.getMapper(StudentRepository.class); Student student=studentRepository.findById(2); System.out.println(student.getName()); sqlSession.close(); //把sqlSession关闭，进行二级缓存测试 sqlSession=sqlSessionFactory.openSession(); studentRepository=sqlSession.getMapper(StudentRepository.class); Student student1=studentRepository.findById(2); System.out.println(student1.getName()); }} 测试结果： ehcache二级缓存 在pom.xml中添加依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache-core&lt;/artifactId&gt;&lt;version&gt;2.4.3&lt;/version&gt;&lt;/dependency&gt; 在resources文件夹下添加ehcache.xml 1234567891011121314&lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"../config/ehcache.xsd\"&gt; &lt;diskStore/&gt; &lt;defaultCache maxElementsInMemory=\"1000\" maxElementsOnDisk=\"10000000\" eternal=\"false\" overflowToDisk=\"false\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"120\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\"&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt; 在MyBatis主配置文件中（Config.xml）开启二级缓存 12345678&lt;settings&gt; &lt;!-- 打印sql--&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;!--开启延迟加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!--开启二级缓存--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;&lt;/settings&gt; Mapper.xml中配置二级缓存 12345678&lt;cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"&gt; &lt;!--缓存创建之后，最后一次访问缓存的时间至缓存失效的时间间隔--&gt; &lt;property name=\"timeToIdleSeconds\" value=\"3600\"/&gt; &lt;!--缓存自创建时间起至失效的时间间隔--&gt; &lt;property name=\"timeToLiveSeconds\" value=\"3600\"/&gt; &lt;!--缓存回收策略，LRU表示移除近期使用最少的对象--&gt; &lt;property name=\"memoryStoreEvictionPolicy\" value=\"LRU\"/&gt;&lt;/cache&gt; MyBatis动态SQL 程序可以自动根据业务参数来决定SQL的组成。 if标签 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.AccountRepository\"&gt; &lt;select id=\"findByAccount\" parameterType=\"com.litao.entity.Account\" resultType=\"com.litao.entity.Account\"&gt; select * from account where &lt;if test=\"id!=null\"&gt; id=#{id} &lt;/if&gt; &lt;if test=\"username!=null\"&gt; and username=#{username} &lt;/if&gt; &lt;if test=\"password!=null\"&gt; and password=#{password} &lt;/if&gt; &lt;/select&gt;&lt;/mapper&gt; if标签可以自动根据表达式的结果来决定是否将对应的语句添加到SQL中，如果条件不成立则不添加，如果条件成立则添加。 where标签 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.AccountRepository\"&gt; &lt;select id=\"findByAccount\" parameterType=\"com.litao.entity.Account\" resultType=\"com.litao.entity.Account\"&gt; select * from account &lt;where&gt; &lt;if test=\"id!=null\"&gt; id=#{id} &lt;/if&gt; &lt;if test=\"username!=null\"&gt; and username=#{username} &lt;/if&gt; &lt;if test=\"password!=null\"&gt; and password=#{password} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; where标签可以自动判断是否要删除语句块中的and关键字，如果检测到where直接跟and拼接，则自动删除and，通常情况下 if 和 where 结合起来使用。 choose、when标签 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.AccountRepository\"&gt; &lt;select id=\"findByAccount\" parameterType=\"com.litao.entity.Account\" resultType=\"com.litao.entity.Account\"&gt; select * from account &lt;where&gt; &lt;choose&gt; &lt;when test=\"id!=null\"&gt; id=#{id} &lt;/when&gt; &lt;when test=\"username!=null\"&gt; username=#{username} &lt;/when&gt; &lt;when test=\"password\"&gt; password=#{password} &lt;/when&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; trim标签 trim标签中的prefix和suffix属性会被用来生成实际的SQL语句，会和标签内部的语句进行拼接，如果语句前后出现了prefixOverrides或者suffixOverrides属性中指定的值，MyBatis框架会自动将其删除。 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.AccountRepository\"&gt; &lt;select id=\"findByAccount\" parameterType=\"com.litao.entity.Account\" resultType=\"com.litao.entity.Account\"&gt; select * from account &lt;trim prefix=\"where\" prefixOverrides=\"and\"&gt; &lt;if test=\"id!=null\"&gt; id=#{id} &lt;/if&gt; &lt;if test=\"username!=null\"&gt; and username=#{username} &lt;/if&gt; &lt;if test=\"password!=null\"&gt; and password=#{password} &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt;&lt;/mapper&gt; set 标签 set标签用于update操作，会自动根据参数选择生成SQL语句。 123456789101112131415&lt;update id=\"update\" parameterType=\"com.litao.entity.Account\"&gt; update account &lt;set&gt; &lt;if test=\"id!=null\"&gt; id=#{id}, &lt;/if&gt; &lt;if test=\"username!=null\"&gt; username=#{username}, &lt;/if&gt; &lt;if test=\"password!=null\"&gt; password!=#{password} &lt;/if&gt; where id=#{id} &lt;/set&gt;&lt;/update&gt; foreach标签 foreach 标签可以迭代生成一系列值，这个标签主要用于SQL的in语句 1234567891011&lt;select id=\"findByIds\" parameterType=\"com.litao.entity.Account\"resultType=\"com.litao.entity.Account\"&gt; select * from account &lt;where&gt; &lt;foreach collection=\"ids\" open=\"id in (\" close=\")\" item=\"id\" separator=\",\"&gt; #{id} &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt;//select * from account where id in (?,?,?...);","link":"/2019/05/19/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B8%89/"},{"title":"MyBatis框架学习二","text":"mysql ：8.0 入门案例测试 读取配置文件 创建SqlSessionFactory工厂 创建工厂mybatis使用了构建者模式（把对象的创建细节隐藏，让使用者直接调用方法即可拿到对象） 使用工厂生产SqlSession对象 生产SqlSession使用了工厂模式（解耦，即降低类之间的依赖关系） 使用SqlSession创建接口的代理对象 session.getMapper(Class type); 创建接口实现类使用了代理模式（不修改源码的基础上对已有方法增强） 使用代理对象执行方法 释放资源 注意事项：不要忘记在映射配置中告诉mybatis要把数据封装到哪个实体类中（设定resultType的值为全类名） 查询所有操作 123456789101112131415161718192021222324252627282930313233/*mybatis 入门案例 */public class MybatisTest { public static void main(String[] args) { //1. 读取配置文件 try { InputStream in= Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2. 创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder(); SqlSessionFactory factory=builder.build(in); //3. 使用工厂生产SqlSession对象 SqlSession session=factory.openSession(); //4. 使用SqlSession创建接口的代理对象 UserRepository userRepository=session.getMapper(UserRepository.class); //5. 使用代理对象执行方法 List&lt;User&gt; users=userRepository.findall(); for(User user:users){ System.out.println(user); } //6. 释放资源 session.close(); in.close(); } catch (IOException e) { e.printStackTrace(); } }} 测试结果： 查询操作代码大致分析 读取配置文件 解析xml ：dom4j selectList方法 根据配置文件的信息创建Connection对象（注册驱动，获取连接） 获取预处理对象PreparedStatement connection.preparedStatement(sql) 执行查询sql语句，返回ResultSet ResultSet resultSet =preparedStatement.executeQuery(); 遍历结构集 resultSet 用于封装 List list =new ArrayList(); while(resultSet.next(){ E element =(E) Class.forName(“全限定类名”).newInstance ()（对应xml中的resultType） 封装:把每个内容添加到element中，再把element加入到list中 根据反射的方式来根据名称获取属性并赋值 list.add(element); } 返回list return list； 执行上述方法需要提供两个信息： 连接信息（用来创建connection） 映射信息：sql语句和封装结果的实体类全限定名（resultType），把这两个信息组合起来定义成一个对象（Map） String Mapper（映射） com.litao.repository.UserRepository String ClassPath findall string sql 根据接口的字节码创建代理对象 public T getMapper(Class type){ /* 类加载器：它使用的和被代理的对象是相同的类加载器 代理对象要实现的接口：在被代理对象实现相同的接口 代理方式：它就是增强的方法，需要自己来提供。此处是InnvocationHandler的接口，需要写一个该接口的实现类，在实现类中调用selectList方法 */ Proxy.newProxyInstance（类加载器，代理对象要实现的接口字节码数组，代理方式） } 这个让我想到了Spring框架中的AOP（面向切面编程）中的代理方式 通过id查询操作 12User user=userRepository.findById(3);System.out.println(user); 查询结果： 通过id删除 123User user=new User(21412,\"小黄\",simpleDateFormat.parse(\"2017-07-15 15:00:05\"),\"女\",\"上海浦东新区\");userRepository.update(22,user);sqlSession.commit(); 修改操作 123User user=new User(21412,\"小黄\",simpleDateFormat.parse(\"2017-07-15 15:00:05\"),\"女\",\"上海浦东新区\");userRepository.update(22,user);sqlSession.commit(); 插入操作 这里使用的是Mybatis原生接口执行添加操作，但不推荐使用原生接口 为实体类创建对应的Mapper.xml,定义管理对象数据的SQL 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.Mapper.UserMapper\"&gt; &lt;!--添加数据--&gt; &lt;insert id=\"save\" parameterType=\"com.litao.entity.User\"&gt; insert into user(username,birthday,sex,address) values(#{username},#{birthday},#{sex},#{address}) &lt;/insert&gt;&lt;/mapper&gt; namespace 通常设置为文件所在包+文件名的形式 insert 标签表示执行添加操作 select 标签表示执行查询操作 update 标签表示更新操作 delete 标签表示删除操作 id 是实际调用Mybatis 方法时需要用到的参数 parameterType 是调用对应方法时参数的数据类型 在全局配置文件中注册UserMapper.xml 123&lt;mappers&gt; &lt;mapper resource=\"com/litao/Mapper/UserMapper.xml\"/&gt;&lt;/mappers&gt; 测试 12345678910111213141516171819202122public class Test { public static void main(String[] args) throws IOException{// InputStream inputStream=Test.class.getClassLoader().getResourceAsStream(\"SqlMapConfig.xml\"); InputStream inputStream= Resources.getResourceAsStream(\"SqlMapConfig.xml\"); SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory=builder.build(inputStream); SqlSession sqlSession=sqlSessionFactory.openSession(); String statement=\"com.litao.Mapper.UserMapper.save\"; SimpleDateFormat simpleDateFormat=new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\"); try { User user=new User(5,\"小红\",simpleDateFormat.parse(\"2017-07-15 15:00:05\"),\"女\",\"上海\"); sqlSession.insert(statement,user); sqlSession.commit(); sqlSession.close(); inputStream.close(); } catch (ParseException e) { e.printStackTrace(); }catch (IOException e){ e.printStackTrace(); } }} 级联查询 实体类： 12345678import lombok.Data;@Datapublic class Student { private long id; private String name; private Classes classes;} 12345678910import lombok.Data;import java.util.List;@Datapublic class Classes { private long id; private String name; private List&lt;Student&gt; students;} 一对一（一个学生对应一个班级） StudentRepository 12345import com.litao.entity.Student;public interface StudentRepository { public Student findById(long id);} StudentRepository.xml 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.StudentRepository\"&gt;&lt;resultMap id=\"studentMap\" type=\"com.litao.entity.Student\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"name\" property=\"name\"&gt;&lt;/result&gt; &lt;association property=\"classes\" javaType=\"com.litao.entity.Classes\"&gt; &lt;id column=\"cid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"cname\" property=\"name\"&gt;&lt;/result&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"findById\" parameterType=\"long\" resultMap=\"studentMap\"&gt; select s.id,s.name,c.id as cid,c.name as cname from student s,classes cwhere s.id = #{id} and s.cid = c.id &lt;/select&gt;&lt;/mapper&gt; 测试结果： Student(id=2, name=李四, classes=Classes(id=2, name=6班, students=null)) 一对多（一个班级对应多个学生） ClassesRepository 12345import com.litao.entity.Classes;public interface ClassesRepository { public Classes findById(long id);} ClassesRepository.xml 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.ClassesRepository\"&gt; &lt;resultMap id=\"classesMap\" type=\"com.litao.entity.Classes\"&gt; &lt;id column=\"cid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"cname\" property=\"name\"&gt;&lt;/result&gt; &lt;collection property=\"students\" ofType=\"com.litao.entity.Student\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findById\" parameterType=\"long\" resultMap=\"classesMap\"&gt; select s.id,s.name,c.id as cid,c.name as cname from student s,classes cwhere c.id = #{id} and s.cid = c.id &lt;/select&gt;&lt;/mapper&gt; 测试结果： Classes(id=2, name=6班, students=[Student(id=1, name=张三, classes=null), Student(id=2, name=李四, classes=null), Student(id=3, name=王五, classes=null)] ) 多对多 多对多即由多个一对多组成","link":"/2019/05/19/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%BA%8C/"},{"title":"Servlet与Jsp学习一","text":"什么是Servlet（控制层的访问） servlet是Java Web开发的基石，与平台无关的服务器组件，它是运行在Servlet容器/Web应用服务器/Tomcat，负责与客户端进行通信 servlet的功能： 创建并返回基于客户请求的动态Html页面 与数据库进行通信 如何使用 Servlet本身是一组接口，自定义一个类，并且实现Servlet接口，这个类就具备了接收客户端请求以及做出响应的功能。 123456789101112131415161718192021222324252627282930313233package com.litao.servlet;import javax.servlet.*;import java.io.IOException;public class MyServlet implements Servlet { @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponseservletResponse) throws ServletException, IOException { String id = servletRequest.getParameter(\"id\"); System.out.println(\"我是Servlet，我已经接收到了客户端发来的请求，参数是\"+id); servletResponse.setContentType(\"text/html;charset=UTF-8;//解决中文输出乱码问题 servletResponse.getWriter().write(\"客户端你好，我已接收到你的请求\"); } @Override public String getServletInfo() { return null; } @Override public void destroy() { }} 浏览器不能直接访问Servlet文件，只能通过映射的方式来间接访问Servlet，映射需要开发者手动配置，有两种配置方式。 基于xml的配置方式 在web.xml中添加 123456789&lt;servlet&gt; &lt;servlet-name&gt;MyServlet01&lt;/servlet-name&gt; &lt;servlet-class&gt;com.litao.servlet.MyServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;!--映射--&gt; &lt;servlet-name&gt;MyServlet01&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 基于注解的方式 1234@WebServlet(\"/demo1\")public class MyServlet implements Servlet { } 上述两种配置方式结果完全一致，将demo1与MyServlet进行映射，即在浏览器地址栏中直接访问domo1就可以映射到MyServlet Servlet生命周期 当浏览器访问servlet时，Tomcat会查询当前servlet的实例化对象是否存在，如果不存在，则通过反射机制动态创建对象，如果存在，直接执行第三步 调用init（）方法完成初始化操作（只调用一次） 调用service方法完成业务逻辑操作（当刷新页面时重新调用服务，不用再初始化） 关闭tomcat时，会调用destory方法，释放当前对象所占用的资源 Servlet 的生命周期方法：无参构造函数、init 无参构造函数，只调用一次，创建对象（通过反射机制来创建对象） init只调用一次，初始化对象 service调用N次，用来执行业务方法 destory只调用一次，销毁对象 ServletConfig 该接口是用来描述Servlet的基本信息的 getServletName（） 返回Servlet的名称，即全类名（带着包名的类名） getInitParameter(String key) 获取init参数的值（在web.xml中配置，&lt;init-param&gt;&lt;/init-parm&gt;） getInitParameterNames() 返回所有的 initParamter 的 name 值，一般用作遍历初始化参数 getServletContext 返回ServletContext对象，它是Servlet的上下文，是整个Servlet的管理者 ServletConfig与ServletContext的区别： ServletConfig作用于某个Servlet实例，每个Servlet都有对应的ServletConfig ServletContext作用于整个web应用，一个Web应用对应一个ServletContext，多个Servlet实例对应一个ServletContext ServletConfig是局部对象，ServletContext是全局对象 Servlet的层次结构 Servlet --》GenericServlet --》HttpServlet GenericServlet 实现了Servlet接口，同时为它的子类屏蔽了不常用的方法,子类只需重写Service方法。 HttpServlet继承GenericServlet ，根据请求类型进行分发处理，Get进入doGet方法，Post进入doPost方法 开发者自定义的Servlet只需要继承HttpServlet即可，重写doGet和doPost 1234567891011121314151617181920212223package com.litao.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/test\")public class TestServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp)throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp)throws ServletException, IOException { }} 什么是 Jsp Jsp本质上是一个Servlet，Jsp主要负责与用户交互，将最终的界面呈现给用户。Jsp是一个Html+Js+Css+Java的混合文件。 当服务器接收到一个后缀是Jsp的请求时，将该请求交给Jsp引擎去处理，每一个Jsp页面第一次被访问时，Jsp引擎会将它翻译成一个Servlet文件（保存在Tomcat的Work文件夹下），再由Web容器调用Servlet完成响应。 单纯从开发的角度看，Jsp就是在Html中嵌入了Java程序。 有3种嵌入方式： Jsp脚本：执行Java逻辑代码 &lt;% Java 代码 %&gt; Jsp声明：定义Java方法 &lt;% 声明Java 方法 %&gt; Jsp表达式：把Java对象直接输出到Html页面中 &lt;%= Java 变量 %&gt; 例子： 1234567891011&lt;%! public String test(){ return \"HelloWorld\";}%&gt;&lt;%String str = test();%&gt;&lt;%=str%&gt; Jsp的9个内置对象 request: 表示一次请求， HttpServletRequest response：表示一次响应， HttpServletResponse pageContext：页面上下文，获取页面信息， PageContext session：表示一次会话，保存用户信息， HttpSession application：表示当前Web应用，全局对象，保存所有用户共享信息，ServletContext config：当前JSP对应的Servlet的ServletConfig对象，获取当前Servlet的信息 out：向浏览器输出数据，JspWriter page：当前Jsp对应的Servlet对象， Servlet exception：表示JSP页面发生的异常，Exception 常用的有request、response、pageContext、session、application request 常用方法： String getParameter（String key） 获取客户端传来的参数，如?id=1&amp;name=tom void setAttribute（String key,Object value） 通过键值对的形式保存数据 Object getAttribute（String key） 通过key取出value RequestDispatcher getRequestDispatcher(String path) 返回一个RequestDispatcher对象，该对象的forward方法用于请求转发 String[] getParameterValues（） 获取客户端传来的多个同名参数 如name=li&amp;name=tom void setCharacterEncoding（String charset） 获取每个请求的编码 reponse常用方法： sendRedirect（String path） 重定向，页面之间的跳转 转发：同一个请求在服务器之间传递，地址栏不变，也叫服务器跳转 重定向：由客户端发送一次新的请求来访问跳转后的目标资源，地址栏改变，也叫客户端跳转 foward（转发）与redirect（重定向）的区别： forward是发生在服务器端，效率更好，而redirect是发生在了客户端 forward是请求转发，只是一次请求，而redirect是相当于了两次请求（第一次请求是客户端发过来的Http请求，服务器的Redirect命令会对该请求发回响应，客户端浏览器得到响应后，会再发送一个新的请求，这个就是第二次请求，它与第一次请求没有关系，所以不会带有第一次请求的信息） forward不会改变客户端的URL显示，而redirect会改变客户端的URL的显示 forward不会销毁request，可以传递request参数，而redirect会销毁request forward只是在原有request请求上再做一次资源的跳转，因此不能访问外部资源，而redirect可以访问外部资源，例如百度。 Session （用户会话） 服务器无法识别每一次Http请求的出处（不知道来自哪个终端），它只会接收到一个请求信号，所以将用户的响应发送给其他人时，必须有一种技术来让服务器知道请求来自哪，这就是会话技术。 会话：就是客户端和服务器之间发生的一系列连续的请求和响应的过程，打开浏览器进行操作到关闭浏览器的过程 会话状态：指服务器和浏览器在会话过程中产生的状态信息，借助于会话状态，服务器能够把属于同一次会话的一系列请求和响应关联起来。 实现会话的两种方式： session cookie 属于同一次会话的请求都有一个相同的标识符 ，sessionID session常用的方法 HttpSession session = request.getSession() 得到session String getId（） 获取sessionID void setMaxInactiveInterval（int interval） 设置session的失效时间，单位为秒，（值为-1 时永不失效） int getMaxMaxInactiveInterval() 获取当前session的失效时间 void setAttribute（String key,Object value） 通过键值对的形式来存储数据 Object getAttribute（String key） 通过key取出value void removeAttribute（String key） 通过键删除对应数据 session.invalidate() 注销request的所有session（可用来退出用户登录） 例如存储用户信息： session.setAttribute(&quot;name&quot;,&quot;admin&quot;) 存 session.getAttribute(&quot;name&quot;) 取 session生命周期： 服务端： 只要Web应用重启或关闭就销毁 客户端： 只要浏览器关闭就销毁 Cookie Cookie是服务端在HTTP响应中附带给浏览器的一个小文本文件，一旦浏览器保存了某个Cookie，在之后的请求和响应过程中，会将此Cookie来回传递，这样就可以通过Cookie这个载体完成客户端和服务端的数据交互。 创建Cookie 12Cookie cookie = new Cookie(\"name\",\"tom\");response.addCookie(cookie); 读取Cookie 1234Cookie[] cookies = request.getCookies();for (Cookie cookie:cookies){ out.write(cookie.getName()+\":\"+cookie.getValue()+\"&lt;br/&gt;\");} Cookie 常用的方法： void SetMaxAge（int age） 设置session的有效时间，单位为秒 int getMaxAge() 获取Cookie的有效时间 int getMaxAge() 获取Cookie的有效时间 int getMaxAge() 获取Cookie的有效时间 例如存储用户信息： response.addCookie(new Cookie(name,&quot;tom&quot;)) 存 取 123456Cookie[] cookies = request.getCookies();for (Cookie cookie:cookies){ if(cookie.getName().equals(\"name\")){ out.write(\"欢迎回来\"+cookie.getValue()); }} Cookie生命周期： 服务端： 不随服务断的重启而销毁 客户端： 默认是只要关闭浏览器就销毁，但可以通过setMaxAge() 方法来设置有效时间。一旦设置了有效时间，则不随浏览器的关闭而销毁，而是由设置的时间来决定。（可通过setMaxage（0）来退出用户登录） Session 与Cookie的区别 Session 保存在服务器中，Cookie保存在个人浏览器中 Session 保存的数据类型是Object ，Cookie保存的数据类型是String Session会随着会话的结束而销毁，Cookie可以长期保存在浏览器中，与会话无关 Session保存重要信息， Cookie保存不重要信息","link":"/2019/02/17/Servlet%E4%B8%8EJsp%E5%AD%A6%E4%B9%A0%E4%B8%80/"},{"title":"Servlet与Jsp学习三","text":"Filter过滤器 与Servlet类似，Filter是Java Web提供的一个接口，只需要自定义一个类并且实现该接口即可。 12345678910111213package com.litao.filter;import javax.servlet.*;import java.io.IOException;public class CharacterFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponseservletResponse, FilterChain filterChain) throws IOException, ServletException { servletRequest.setCharacterEncoding(\"UTF-8\"); filterChain.doFilter(servletRequest,servletResponse); }} 注意：doFilter ⽅法中处理完业务逻辑之后，必须添加 1filterChain.doFilter(servletRequest,servletResponse); 否则请求/响应无法向后传递，⼀直停留在过滤器中。 作用： 用来拦截传入的请求和传出的响应 修改或以某中方式处理正在客户端和服务端之间交换的数据流 使用 基于web.xml配置Filter 12345678&lt;filter&gt; &lt;filter-name&gt;charcater&lt;/filter-name&gt; &lt;filter-class&gt;com.litao.filter.CharacterFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;charcater&lt;/filter-name&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 基于注解配置Filter 1234@WebFilter(\"/login\")public class CharacterFilter implements Filter {} 上述两种配置方式，结果一样 Filter生命周期 当Tomcat启动时，通过反射机制调用Filter的无参构造函数创建实例化对象，同时调用init方法实现初始化，doFilter方法调用多次，当Tomcat关闭时，调用destoty来销毁Filter对象 无参构造函数：只调用一次，当Tomcat启动时调用（Filter一定要进行配置） init方法：只调用一次，当Filter的实例化对象创建完成之后调用 doFilter：调用多次，访问Filter的业务逻辑都写在Filter中 destory：只调用一次，Tomcat关闭时使用 同时配置多个Filter时，Filter的调用顺序是由web.xml的配置顺序来决定的，写在上面的配置先调用，因为web.xml是从上到下顺序读取的。 Filter使用场景举例 统一处理中文乱码 屏蔽敏感词 12345678910111213141516171819package com.litao.filter;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException;@WebFilter(\"/test\")public class WordFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponseservletResponse, FilterChain filterChain) throws IOException, ServletException { servletRequest.setCharacterEncoding(\"UTF-8\"); //将\"敏感词\"替换成\"***\" String name = servletRequest.getParameter(\"name\"); name = name.replaceAll(\"敏感词\",\"***\"); servletRequest.setAttribute(\"name\",name); filterChain.doFilter(servletRequest,servletResponse); }} 控制资源访问权限 123456789101112131415161718192021222324252627package com.litao.filter;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;@WebFilter(\"/download.jsp\")public class DownloadFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponseservletResponse, FilterChain filterChain) throws IOException, ServletException{ HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; HttpSession session = request.getSession(); String name = (String) session.getAttribute(\"name\"); if(name == null){ //不是登录状态 response.sendRedirect(\"/login.jsp\"); }else{ filterChain.doFilter(servletRequest,servletResponse); } }} 文件的上传与下载 文件上传 Jsp input的type设置为file form表单的method设置post，get请求只会将文件名传给服务器，而不是文件本身 form表单的enctype设置multipart/form-data，以二进制的形式传输数据 12345678910111213&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form enctype=\"multipart/form-data\" action=\"/upload\" method=\"post\"&gt; &lt;input name=\"desc\" type=\"text\"/&gt;&lt;br/&gt; &lt;input name=\"text\" type=\"file\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"上传\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; Servlet fileupload组件可以将所有的请求信息都解析成FileItem对象，可以通过FileItem对象的操作完成上传，体现面向对象的思想。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.litao.servlet;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.FileUploadException;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.*;import java.util.List;@WebServlet(\"/upload\")public class UploadServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp)throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp)throws ServletException, IOException {// //通过输⼊流获取客户端传来的数据流// InputStream inputStream = req.getInputStream();// Reader reader = new InputStreamReader(inputStream);// BufferedReader bufferedReader = new BufferedReader(reader);// //通过输出流将数据流输出到本地硬盘// //获取⽂件夹的绝对路径// String path = req.getServletContext().getRealPath(\"file/copy.txt\");// OutputStream outputStream = new FileOutputStream(path);// Writer writer = new OutputStreamWriter(outputStream);// BufferedWriter bufferedWriter = new BufferedWriter(writer);// String str = \"\";// while((str = bufferedReader.readLine())!=null){// System.out.println(str);// bufferedWriter.write(str);// }// bufferedWriter.close();// writer.close();// outputStream.close();// bufferedReader.close();// reader.close();// inputStream.close(); try { DiskFileItemFactory fileItemFactory = new DiskFileItemFactory(); ServletFileUpload servletFileUpload = new ServletFileUpload(fileItemFactory); List&lt;FileItem&gt; list = servletFileUpload.parseRequest(req); for(FileItem fileItem : list){ if(fileItem.isFormField()){ String name = fileItem.getFieldName(); String value = fileItem.getString(\"UTF-8\"); System.out.println(name+\":\"+value); }else{ String fileName = fileItem.getName(); long size = fileItem.getSize(); System.out.println(fileName+\":\"+size+\"Byte\"); InputStream inputStream = fileItem.getInputStream();// Reader reader = new InputStreamReader(inputStream);// BufferedReader bufferedReader = new BufferedReader(reader); String path =req.getServletContext().getRealPath(\"file/\"+fileName); OutputStream outputStream = new FileOutputStream(path);// Writer writer = new OutputStreamWriter(outputStream);// BufferedWriter bufferedWriter = new BufferedWriter(writer); int temp = 0; while((temp = inputStream.read())!=-1){ outputStream.write(temp); }// bufferedWriter.close();// writer.close(); outputStream.close();// bufferedReader.close();// reader.close(); inputStream.close(); System.out.println(\"上传成功\"); } } } catch (FileUploadException e) { e.printStackTrace(); } }} 文件下载 Jsp 12345678910&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;文件下载&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"/test/download?type=img\"&gt;图片&lt;/a&gt; &lt;a href=\"/test/download?type=txt\"&gt;文本&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; Servlet 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.litao.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;@WebServlet(\"/download\")public class DownLoadServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String type=req.getParameter(\"type\"); String filename=\"\"; switch (type){ case\"img\": filename=\"1.png\"; break; case\"txt\": filename=\"1.txt\"; break; } //设置响应方式 resp.setContentType(\"application/x-msdownload\"); //设置下载后的文件名 resp.setHeader(\"Content-Disposition\",\"attachment;filename=\"+filename); //获取输出流 OutputStream outputStream=resp.getOutputStream(); String path=req.getServletContext().getRealPath(\"file/\"+filename); InputStream inputStream=new FileInputStream(path); int temp=0; while ((temp=inputStream.read())!=-1){ outputStream.write(temp); } inputStream.close(); outputStream.close(); }} Ajax 概述 Asynchronous JavaScript And XML: 异步的JavaScript和XML Ajax是一种交互方式，异步加载，客户端和服务器的数据交互更新在局部页面的技术，不需要刷新整个页面（局部更新） 优点： 局部刷新，效率更高 用户体验更好 Ajax原理图 基于JQuery的Ajax 语法 $.ajax({属性}) 常用的属性参数： url：请求的后端服务地址 type：请求方式，默认 get data：请求参数 data Type：服务器返回的数据类型，text/json success：请求成功的回调函数 error：请求失败的回调函数 complete：请求完成的回调函数（无论成功或者失败，都会调用） 例子 12345678910111213141516171819202122232425262728&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.3.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function(){ var btn = $(\"#btn\"); btn.click(function(){ $.ajax({ url:'/test', type:'post', data:'id=1', dataType:'text', success:function(data){ var text = $(\"#text\"); text.before(\"&lt;span&gt;\"+data+\"&lt;/span&gt;&lt;br/&gt;\"); } }); }); }) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input id=\"text\" type=\"text\"/&gt;&lt;br/&gt; &lt;input id=\"btn\" type=\"button\" value=\"提交\"/&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324package com.litao.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/test\")public class TestServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp)throws ServletException, IOException { String id = req.getParameter(\"id\"); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } String str = \"Hello World\"; resp.getWriter().write(str); }} 传统数据交互与Ajax数据交互的对比 客户端请求的方式不同： 传统：浏览器发送同步请求 Ajax：异步引擎对象发送异步请求 服务器响应的方式不同： 传统：响应一个完整的Jsp页面（视图） Ajax：响应需要的数据 客户端处理的方式不同： 传统：需要等待服务器完成响应并且重新加载整个页面之后，用户才能进行后续的操作 Ajax：动态更新页面中的局部内容，不影响用户的其他操作 Json 概述 JavaScript Object Notation ,一种轻量级数据交互格式，完成Js与Java等开发语言对象数据之间的转换。 客户端和服务器之间传递对象数据，需要用JSON格式 123456789101112package com.litao.entity;import lombok.Data;@Data@AllArgsConstructorpublic class User { private Integer id; private String name; private Double score;}User user = new User(1,\"张三\",95); 12345var user = { id:1, name:\"张三\", score:95} 例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.3.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function(){ //修改省份 $(\"#province\").change(function () { var id = $(this).val(); $.ajax({ url:\"/location\", type:\"POST\", data:\"id=\"+id+\"&amp;type=province\", dataType:\"JSON\", success:function(data){ var content = \"\"; var cities = data.cities; for(var i=0;i&lt;cities.length;i++){ content += \"&lt;option&gt;\"+cities[i]+\"&lt;/option&gt;\"; } $(\"#city\").html(content); content = \"\"; var areas = data.areas; for(var i=0;i&lt;areas.length;i++){ content += \"&lt;option&gt;\"+areas[i]+\"&lt;/option&gt;\"; } $(\"#area\").html(content); } }); }); //修改城市 $(\"#city\").change(function(){ var id = $(this).val(); $.ajax({ url:\"/location\", type:\"POST\", data:\"id=\"+id+\"&amp;type=city\", dataType:\"JSON\", success:function(data){ var content = \"\"; for(var i=0;i&lt;data.length;i++){ content += \"&lt;option&gt;\"+data[i]+\"&lt;/option&gt;\"; } $(\"#area\").html(content); } }); }); }); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 省：&lt;select id=\"province\"&gt; &lt;option value=\"陕⻄省\"&gt;陕⻄省&lt;/option&gt; &lt;option value=\"河南省\"&gt;河南省&lt;/option&gt; &lt;option value=\"江苏省\"&gt;江苏省&lt;/option&gt; &lt;/select&gt; 市：&lt;select id=\"city\"&gt; &lt;option value=\"⻄安市\"&gt;⻄安市&lt;/option&gt; &lt;option value=\"宝鸡市\"&gt;宝鸡市&lt;/option&gt; &lt;option value=\"渭南市\"&gt;渭南市&lt;/option&gt; &lt;/select&gt; 区：&lt;select id=\"area\"&gt; &lt;option&gt;雁塔区&lt;/option&gt; &lt;option&gt;莲湖区&lt;/option&gt; &lt;option&gt;新城区&lt;/option&gt; &lt;/select&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324package com.litao.entity;import java.util.List;public class Location { private List&lt;String&gt; cities; private List&lt;String&gt; areas; public List&lt;String&gt; getCities() { return cities; } public void setCities(List&lt;String&gt; cities) { this.cities = cities; } public List&lt;String&gt; getAreas() { return areas; } public void setAreas(List&lt;String&gt; areas) { this.areas = areas; }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.litao.servlet;import com.southwind.entity.Location;import net.sf.json.JSONArray;import net.sf.json.JSONObject;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;@WebServlet(\"/location\")public class LocationServlet extends HttpServlet { private static Map&lt;String, List&lt;String&gt;&gt; cityMap; private static Map&lt;String,List&lt;String&gt;&gt; provinceMap; static { cityMap = new HashMap&lt;&gt;(); List&lt;String&gt; areas = new ArrayList&lt;&gt;(); //⻄安 areas.add(\"雁塔区\"); areas.add(\"莲湖区\"); areas.add(\"新城区\"); cityMap.put(\"⻄安市\",areas); //宝鸡 areas = new ArrayList&lt;&gt;(); areas.add(\"陈仓区\"); areas.add(\"渭宾区\"); areas.add(\"新城区\"); cityMap.put(\"宝鸡市\",areas); //渭南 areas = new ArrayList&lt;&gt;(); areas.add(\"临渭区\"); areas.add(\"⾼新区\"); cityMap.put(\"渭南市\",areas); //郑州 areas = new ArrayList&lt;&gt;(); areas.add(\"郑州A区\"); areas.add(\"郑州B区\"); cityMap.put(\"郑州市\",areas); //洛阳 areas = new ArrayList&lt;&gt;(); areas.add(\"洛阳A区\"); areas.add(\"洛阳B区\"); cityMap.put(\"洛阳市\",areas); provinceMap = new HashMap&lt;&gt;(); List&lt;String&gt; cities = new ArrayList&lt;&gt;(); cities.add(\"⻄安市\"); cities.add(\"宝鸡市\"); cities.add(\"渭南市\"); provinceMap.put(\"陕⻄省\",cities); cities = new ArrayList&lt;&gt;(); cities.add(\"郑州市\"); cities.add(\"洛阳市\"); cities.add(\"开封市\"); provinceMap.put(\"河南省\",cities); cities = new ArrayList&lt;&gt;(); cities.add(\"南京市\"); cities.add(\"苏州市\"); cities.add(\"南通市\"); provinceMap.put(\"江苏省\",cities); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp)throws ServletException, IOException { String type = req.getParameter(\"type\"); resp.setCharacterEncoding(\"UTF-8\"); String id = req.getParameter(\"id\"); switch (type){ case \"city\": List&lt;String&gt; areas = cityMap.get(id); JSONArray jsonArray = JSONArray.fromObject(areas); resp.getWriter().write(jsonArray.toString()); break; case \"province\": List&lt;String&gt; cities = provinceMap.get(id); String city = cities.get(0); List&lt;String&gt; cityAreas = cityMap.get(city); Location location = new Location(); location.setCities(cities); location.setAreas(cityAreas); JSONObject jsonObject = JSONObject.fromObject(location); resp.getWriter().write(jsonObject.toString()); break; } }}","link":"/2019/02/19/Servlet%E4%B8%8EJsp%E5%AD%A6%E4%B9%A0%E4%B8%89/"},{"title":"Servlet与Jsp学习二","text":"Jsp 4大内置对象作用域 page、request、session、application 都具有setAttribute和getAttribute方法 page的作用域： 对应的内置对象是pageContext request作用域： 对应的内置对象是requset session的作用域：对应的内置对象是session application的作用域：对应的内置对象是application page &lt; request &lt; session &lt; application page只在当前页面有效 request在一次请求内有效 session在一次会话中有效 application对应整个web应用 application例子： 网址访问量统计： 123456789101112&lt;% Integer count = (Integer) application.getAttribute(\"count\"); if(count == null){ count = 1; application.setAttribute(\"count\",count); }else{ count++; application.setAttribute(\"count\",count); }%&gt;您是当前的第&lt;%= count %&gt;位访客 EL表达式 Expression Language 表达式语言，替代Jsp页面中数据访问时的复杂编码，可以非常便捷地取出域对象（pageContext、request、session、application）中保存的数据，前提是一定要先setAttribute，EL就相当于在简化getAtrribute。 使用 ${ 变量名 } 变量名就是setAttribute对应的key值 EL表达式对4中域对象的默认查找顺序： pageContext --》request - -》 session --》 application 按照上述的顺序进行查找，找到立即返回，如果在application中也无法找到，则返回null 指定作用域查找 pageContext： ${pageScope.变量名} request： ${requestScope.变量名} session： ${sessionScope.变量名} application： ${applicationScope. 变量名} 数据级联 12345678910111213141516171819&lt;% User user = new User(1,\"张三\",86.5,new Address(1,\"上海\")); System.out.println(user.toString()); pageContext.setAttribute(\"user\",user); %&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;成绩&lt;/th&gt; &lt;th&gt;地址&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;${user.id}&lt;/td&gt; &lt;td&gt;${user.name}&lt;/td&gt; &lt;td&gt;${user.score}&lt;/td&gt; &lt;td&gt;${user.address}&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; user.id 调用的是id方法： 把 id 变为 Id 找到 getId () 方法 EL执行表达式 12345678910111213${num1&amp;&amp;num2}&amp;&amp; || ! &lt; &gt; &lt;= &lt;= ==&amp;&amp; and|| or! not== eq!= ne&lt; lt&gt; gt&lt;= le&gt;= geempty 变量为 null，⻓度为0的String， size为0的集合 JSTL JSP Standard Tag Library JSP 标准标签库，JSP为开发者提供的一系列的标签，使用这些标签可以完成一些逻辑处理，比如循环遍历集合，让代码更加简洁。 JSTL 侧重于逻辑处理 EL负责展示数据 JSTL优点： 提供了统一的标签 可以用于编写各种动态功能 使用 添加依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt; 在Jsp页面开始的地方导入JSTL核心标签库 1&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt; JSTL核心标签库常用标签： set、out、remove、catch set：向域对象中添加数据 12345678910111213141516&lt;% requset.setAttribute(key,value)%&gt;&lt;c:set var=\"name\" value=\"tom\" scope=\"request\"&gt;&lt;/c:set&gt;${requestScope.name}&lt;%User user = new User(1,\"张三\",66.6,new Address(1,\"上海\"));request.setAttribute(\"user\",user);%&gt;${user.name}&lt;hr/&gt;&lt;c:set target=\"${user}\" property=\"name\" value=\"李四\"&gt;&lt;/c:set&gt;${user.name} out：输出域对象中的数据 123&lt;c:set var=\"name\" value=\"tom\"&gt;&lt;/c:set&gt;&lt;c:out value=\"${name}\" default=\"未定义\"&gt;&lt;/c:out&gt; remove：删除域对象中的数据 123&lt;c:remove var=\"name\" scope=\"page\"&gt;&lt;/c:remove&gt;&lt;c:out value=\"${name}\" default=\"未定义\"&gt;&lt;/c:out&gt; catch：捕捉异常 123456&lt;c:catch var=\"error\"&gt; &lt;% int a = 10/0; %&gt;&lt;/c:catch&gt;${error} 条件标签： if 、choose 123456789&lt;c:set var=\"num1\" value=\"1\"&gt;&lt;/c:set&gt;&lt;c:set var=\"num2\" value=\"2\"&gt;&lt;/c:set&gt;&lt;c:if test=\"${num1&gt;num2}\"&gt;ok&lt;/c:if&gt;&lt;c:if test=\"${num1&lt;num2}\"&gt;fail&lt;/c:if&gt;&lt;hr/&gt;&lt;c:choose&gt; &lt;c:when test=\"${num1&gt;num2}\"&gt;ok&lt;/c:when&gt; &lt;c:otherwise&gt;fail&lt;/c:otherwise&gt;&lt;/c:choose&gt; 迭代标签：forEach 1234&lt;c:forEach items=\"${list}\" var=\"str\" begin=\"2\" end=\"3\" step=\"2\"varStatus=\"sta\"&gt; ${sta.count}、${str}&lt;br/&gt;&lt;/c:forEach&gt; 格式化标签库常用标签 1&lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %&gt; 1234567&lt;%request.setAttribute(\"date\",new Date());%&gt;&lt;fmt:formatDate value=\"${date}\" pattern=\"yyyy-MM-dd HH:mm:ss\"&gt;&lt;/fmt:formatDate&gt;&lt;br/&gt;&lt;fmt:formatNumber value=\"32145.23434\" maxIntegerDigits=\"2\"maxFractionDigits=\"3\"&gt;&lt;/fmt:formatNumber&gt; 函数标签库常用标签 1&lt;%@ taglib prefix=\"fn\" uri=\"http://java.sun.com/jsp/jstl/functions\" %&gt; 12345678910&lt;%request.setAttribute(\"info\",\"Java,C\");%&gt;${fn:contains(info,\"Python\")}&lt;br/&gt;${fn:startsWith(info, \"Java\")}&lt;br/&gt;${fn:endsWith(info, \"C\")}&lt;br/&gt;${fn:indexOf(info, \"va\")}&lt;br/&gt;${fn:replace(info, \"C\",\"Python\")}&lt;br/&gt;${fn:substring(info, 2, 3)}&lt;br/&gt;${fn:split(info, \",\")[0]}-${fn:split(info, \",\")[1]}","link":"/2019/02/18/Servlet%E4%B8%8EJsp%E5%AD%A6%E4%B9%A0%E4%BA%8C/"},{"title":"Spring MVC学习一","text":"概述 SpringMVC是MVC设计模式的框架，是Spring框架的一个分支产品，以SpringIoC容器为基础，并利用容器的特性来简化它的配置。 Spring MVC相当于Spring的一个子模块，可以很好得和Spring结合起来进行开发。 Spring MVC 的特点： 清晰的角色划分 灵活的配置功能 提供了大量的控制器接口和实现类 分离View层的实现 国际化支持 面向接口编程 MVC设计模式 MVC 是一种开发模式，将程序分层的一种思想。 M: Model 业务数据（service、repository、entity） V：View 视图(JSP、html、App客户端) C：Controller 控制层（Servlet、Handler、Action） MVC 将应用程序分为 Controller、Model、View 三层，Controller 接收客户端请求，调用 Model 生成业务数据，传递给 View。 Spring MVC 就是对这套流程的封装，屏蔽了很多底层代码，开放出接口，让开发者可以更加轻松、便捷地完成基于 MVC 模式的 Web 开发 Spring MVC 核心组件 DispatcherServlet：前置控制器，是整个流程的核心，控制其他组件的执行，进行统一的调度，降低组件之间的耦合性，相当于总指挥 Handler：处理器，完成具体的业务逻辑，相当于Servlet或Action HandlerMapping：DispatcherServlet接收到请求之后，通过HandlerMapping将不同的请求映射到不同的Handler HandlerInterceptor：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口 HandlerExecutionChain：处理器执行链，包括两部分内容：Handler和HandlerInterceptor（系统会有一个默认的HandlerInterceptor，如果需要额外设置拦截，可以添加拦截器） HandlerAdapter：处理器适配器，Handler执行业务方法之前，需要进行一系列的操作，包括表单数据的验证、数据类型的转换、将表单数据封装到JavaBean等，这些操作都是由HandlerApater来完成，开发者只需要将注意力集中业务逻辑的处理上，DispatcherServlet通过HandlerAdapter执行不同的Handler ModelAndView：装载了模型数据和试图信息，作为Handlerd的处理结果，返回给DispatcherServlet ViewResolver：视图解析器，DispatcherServlet通过它将逻辑视图解析为物理视图，最终将渲染结果响应给客户端 Spring MVC 工作流程 客户端请求被DispatcherServlet接收 根据HandlerMapping映射到Handler 生成Handler和HandlerInterceptor Handler和HandlerInterceptor以HandlerExecutionChain的形式一并返回给DisptacherServlet DispatcherServlet通过HandlerAdapter调用Handler的方法完成业务逻辑处理 Handler返回一个ModelAndView给DispatcherServlet DispatcherServlet将获取到的ModelAndView对象传给ViewResolver视图解析器，将逻辑视图解析为物理View ViewResovler返回一个View给DispatcherServlet DispatcherServlet根据View进行视图渲染（将模型数据Model填充到视图View中） DispatcherServlet将渲染后的结果响应给客户端 使用 在pom.xml中添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在 web.xml 中配置 DispatcherServlet 12345678910111213141516171819202122&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; springmvc.xml 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd\"&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package=\"com.litao\"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 创建Handler 1234567891011121314package com.litao.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HelloHandler { @RequestMapping(\"/index\") public String index(){ System.out.println(\"执行了index...\"); return \"index\"; }} Spring MVC 注解 @RequestMapping Spring MVC 通过 @RequestMapping 注解将 URL 请求与业务方法进行映射，在 Handler 的类定义处以及方法定义处都可以添加 @RequestMapping ，在类定义处添加，相当于客户端多了一层访问路径。 @RequestMapping 相关参数 value: 指定 URL 请求的实际地址，是 @RequestMapping 的默认值@RequestMapping(value=&quot;index&quot;) method : 指定请求的method类型，如GET、POST、PUT、DELET @RequestMapping(value = &quot;/index&quot;,method = RequestMethod.GET)表示方法只能接收GET请求 params：指定请求中必须包含某些参数，否则无法调用该方法 @RequestMapping(value = &quot;/index&quot;,method = RequestMethod.GET,params = {&quot;name&quot;,&quot;id=10&quot;}) 表示请求中必须包含 name 和 id 两个参数，同时 id 的值必须是 10 关于参数绑定，在形参列表中通过添加 @RequestParam 注解完成 HTTP 请求参数与业务方法形参的映射 123456@RequestMapping(value = \"/index\",method = RequestMethod.GET,params = {\"name\",\"id=10\"})public String index(@RequestParam(\"name\") String str,@RequestParam(\"id\") int age){ System.out.println(str); System.out.println(age); return \"index\";} 上述代码表示将请求的参数 name 和 id 分别赋给了形参 str 和 age ，同时自动完成了数据类型转换，将 “10” 转为了 int 类型的 10，再赋给 age，这些工作都是由 HandlerAdapter 来完成的 Spring MVC 也支持 RESTful 风格的 URL 传统类型：http://localhost:8080/index?name=zhangsan&amp;id=10 REST：http://localhost:8080/index/zhangsan/10 123456@RequestMapping(\"/rest/{name}/{id}\")public String rest(@PathVariable(\"name\") String name,@PathVariable(\"id\") int id){ System.out.println(name); System.out.println(id); return \"index\";} @Controller @Controller 在类定义处添加，将该类交个 IoC 容器来管理（结合 springmvc.xml 的自动扫描配置使用），同时使其成为一个控制器，可以接收客户端请求。 映射Cookie Spring MVC 通过映射可以直接在业务方法中获取 Cookie 的值 12345@RequestMapping(\"/cookie\")public String cookie(@CookieValue(value = \"JSESSIONID\") String sessionId){ System.out.println(sessionId); return \"index\";} 使用JavaBean绑定参数 Spring MVC 会根据请求参数名和 JavaBean 属性名进行自动匹配，自动为对象填充属性值，同时支持及联属性。 12345678910package com.litao.entity;import lombok.Data;@Datapublic class User { private long id; private String name; private Address address;} 12345678package com.litao.entity;import lombok.Data;@Datapublic class Address { private String value;} 1234567891011121314&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/hello/save\" method=\"post\"&gt; 用户id：&lt;input type=\"text\" name=\"id\"/&gt;&lt;br/&gt; 用户名：&lt;input type=\"text\" name=\"name\"/&gt;&lt;br/&gt; 用户地址：&lt;input type=\"text\" name=\"address.value\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"注册\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789@Controller@RequestMapping(\"/hello\")public class TestHandler { @RequestMapping(value = \"/save\",method = RequestMethod.POST) public String save(User user){ System.out.println(user); return \"index\"; }} 如果出现中文乱码问题，只需在 web.xml 添加 Spring MVC 自带的过滤器即可 12345678910111213&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; JSP 页面的转发和重定向 转发 12345@RequestMapping(\"/forward\")public String forward(){ return \"forward:/index.jsp\"; // return \"index\";} 重定向 1234@RequestMapping(\"/redirect\")public String redirect(){ return \"redirect:/index.jsp\";}","link":"/2019/04/07/Spring-MVC%E5%AD%A6%E4%B9%A0%E4%B8%80/"},{"title":"Spring MVC学习二","text":"Spring MVC 数据绑定 数据绑定：在后端的业务方法中直接获取客户端 HTTP 请求中的参数，将请求参数映射到业务方法的形参中，Spring MVC 中数据绑定的工作是由 HandlerAdapter 来完成的。 基本数据类型 12345@RequestMapping(\"/baseType\")@ResponseBodypublic String baseType(int id){ return id+\"\";} @ResponseBody 表示 Spring MVC 会直接将业务方法的返回值响应给客户端，如果不加 @ResponseBody 注解，Spring MVC 会将业务方法的放回值传递给 DispatcherServlet，再由 DisptacherServlet 调用 ViewResolver 对返回值进行解析，映射到一个 JSP 资源。 包装类 12345@RequestMapping(\"/packageType\")@ResponseBodypublic String packageType(@RequestParam(value = \"num\",required = false,defaultValue = \"0\") Integer id){ return id+\"\";} 包装类可以接收 null，当 HTTP 请求没有参数时，使用包装类定义形参的数据类型，程序不会抛出异常。 @RequestParam value = “num”：将 HTTP 请求中名为 num 的参数赋给形参 id。 requried：设置 num 是否为必填项，true 表示必填，false 表示非必填，可省略。 defaultValue = “0”：如果 HTTP 请求中没有 num 参数，默认值为0. 数组 123456789@RestController@RequestMapping(\"/data\")public class DataBindHandler { @RequestMapping(\"/array\") public String array(String[] name){ String str = Arrays.toString(name); return str; }} @RestController 表示该控制器会直接将业务方法的返回值响应给客户端，不进行视图解析。 @Controller 表示该控制器的每一个业务方法的返回值都会交给视图解析器进行解析，如果只需要将数据响应给客户端，而不需要进行视图解析，则需要在对应的业务方法定义处添加 @ResponseBody。 12345678910@Controller@RequestMapping(\"/data\")public class DataBindHandler { @RequestMapping(\"/array\") @ResponseBody public String array(String[] name){ String str = Arrays.toString(name); return str; }} 上述两组代码效果一样 List Spring MVC 不支持 List 类型的直接转换，需要对 List 集合进行包装 集合封装类 12345678910package com.litao.entity;import lombok.Data;import java.util.List;@Datapublic class UserList { private List&lt;User&gt; users;} Jsp 1234567891011121314151617&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/list\" method=\"post\"&gt; 用户1编号：&lt;input type=\"text\" name=\"users[0].id\"/&gt;&lt;br/&gt; 用户1名称：&lt;input type=\"text\" name=\"users[0].name\"/&gt;&lt;br/&gt; 用户2编号：&lt;input type=\"text\" name=\"users[1].id\"/&gt;&lt;br/&gt; 用户2名称：&lt;input type=\"text\" name=\"users[1].name\"/&gt;&lt;br/&gt; 用户3编号：&lt;input type=\"text\" name=\"users[2].id\"/&gt;&lt;br/&gt; 用户3名称：&lt;input type=\"text\" name=\"users[2].name\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 业务方法 12345678@RequestMapping(\"/list\")public String list(UserList userList){ StringBuffer str = new StringBuffer(); for(User user:userList.getUsers()){ str.append(user); } return str.toString();} 处理 @ResponseBody 中文乱码，在 springmvc.xml 中配置消息转换器 12345678&lt;mvc:annotation-driven&gt; &lt;!-- 消息转换器 --&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\" value=\"text/html;charset=UTF-8\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; Map Jsp 1234567891011121314151617&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/data/map\" method=\"post\"&gt; 用户1编号：&lt;input type=\"text\" name=\"users['a'].id\"/&gt;&lt;br/&gt; 用户1名称：&lt;input type=\"text\" name=\"users['a'].name\"/&gt;&lt;br/&gt; 用户2编号：&lt;input type=\"text\" name=\"users['b'].id\"/&gt;&lt;br/&gt; 用户2名称：&lt;input type=\"text\" name=\"users['b'].name\"/&gt;&lt;br/&gt; 用户3编号：&lt;input type=\"text\" name=\"users['c'].id\"/&gt;&lt;br/&gt; 用户3名称：&lt;input type=\"text\" name=\"users['c'].name\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 自定义封装类 12345678910package com.litao.entity;import lombok.Data;import java.util.Map;@Datapublic class UserMap { private Map&lt;String,User&gt; users;} 业务方法 12345678910111213@RestController@RequestMapping(\"/data\")public class MapHandler{ @RequestMapping(\"/map\") public String map(UserMap userMap){ StringBuffer str=new StringBuffer(); for(String key:userMap.getUsers().keySet()){ User user=userMap.getUsers().get(key); str.append(user); } return str.toString(); }} Json 客户端发送Json格式的数据，直接通过Spring MVC绑定到业务方法的形参中。 处理Spring MVC无法加载的静态资源如 js 文件，在web.xml中添加配置即可 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.js&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; Jsp 1234567891011121314151617181920212223242526272829&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.4.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function(){ var user = { \"id\":1, \"name\":\"张三\" }; $.ajax({ url:\"/data/json\", data:JSON.stringify(user), type:\"POST\", contentType:\"application/json;charset=UTF-8\", dataType:\"JSON\", success:function(data){ alert(data.id+\"---\"+data.name); } }) }); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 业务方法 12345678910111213141516171819202122package com.litao.controller;import com.litao.entity.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestController;@Controller@RequestMapping(\"/data\")public class JsonTestHandler { @RequestMapping(\"/json\") @ResponseBody public User json(@RequestBody User user){ System.out.println(user); user.setId(6); user.setName(\"张三\"); return user; }} Spring MVC 中的 Json 和 JavaBean 的转换需要借助于 fastjson，pom.xml 引入相关依赖。 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.32&lt;/version&gt;&lt;/dependency&gt; springmvc.xml 添加 fastjson 配置 12345678910&lt;mvc:annotation-driven&gt; &lt;!--消息转换器--&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\" value=\"text/html;charset=UTF-8\"/&gt; &lt;/bean&gt; &lt;!--配置fastjson--&gt; &lt;bean class=\"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter4\"/&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; Spring MVC 模型数据解析 Jsp 四大作用域对应的内置对象：pageContext、request、session、application 模型数据的绑定是由ViewResolver来完成的，开发中，需要先添加数据模型，再交给ViewResolver来绑定 Spring MVC 提供的添加模型数据的方式： Map Model ModelAndView @SessionAttribute ModelAttribute Map 业务方法 12345678910111213@Controller@RequestMapping(\"/data\")public class MapHandler{ @RequestMapping(\"/map\") public String map(Map&lt;String,User&gt; map) { User user=new User(); user.setId(1L); user.setName(\"张三\"); map.put(\"user\",user); return \"test001\"; }} test001.jsp 12345678910 &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;%@ page isELIgnored=\"false\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt;jsp &lt;/head&gt;&lt;body&gt; ${requestScope.user} &lt;/body&gt; &lt;/html&gt; Model 12345678910111213@Controller@RequestMapping(\"/data\")public class ModelHandler { @RequestMapping(\"/model\") public String model(Model model){ User user=new User(); user.setId(2); user.setName(\"张三\"); model.addAttribute(\"user\",user); return \"test001\"; }} ModelAndView 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798@Controller@RequestMapping(\"/data\")public class ModelAndViewHandler { //第一种方式 @RequestMapping(\"/modelandview1\") public ModelAndView modelAndView1(){ User user=new User(); user.setId(1L); user.setName(\"张三\"); ModelAndView modelAndView=new ModelAndView(); modelAndView.addObject(\"user\",user); modelAndView.setViewName(\"test001\"); return modelAndView; } //第二种方式 @RequestMapping(\"/modelandview2\") public ModelAndView modelAndView2(){ User user=new User(); user.setId(1L); user.setName(\"张三\"); ModelAndView modelAndView=new ModelAndView(); modelAndView.addObject(\"user\",user); View view=new InternalResourceView(\"/test001.jsp\"); modelAndView.setView(view); return modelAndView; } //第三种方式 @RequestMapping(\"/modelandview3\") public ModelAndView modelAndView3(){ User user=new User(); user.setId(1L); user.setName(\"张三\"); ModelAndView modelAndView=new ModelAndView(\"test001\"); modelAndView.addObject(\"user\",user); return modelAndView; } //第四种方式 @RequestMapping(\"/modelandview4\") public ModelAndView modelAndView4(){ User user=new User(); user.setId(1L); user.setName(\"张三\"); View view=new InternalResourceView(\"/test001.jsp\"); ModelAndView modelAndView=new ModelAndView(view); modelAndView.addObject(\"user\",user); return modelAndView; } //第五种方式 @RequestMapping(\"/modelandview5\") public ModelAndView modelAndView5(){ User user=new User(); user.setId(1L); user.setName(\"张三\"); Map&lt;String,User&gt; map=new HashMap&lt;&gt;(); map.put(\"user\",user); ModelAndView modelAndView=new ModelAndView(\"test001\",map); return modelAndView; } //第六种方式 @RequestMapping(\"/modelandview6\") public ModelAndView modelAndView6(){ User user=new User(); user.setId(1L); user.setName(\"张三\"); Map&lt;String,User&gt; map=new HashMap&lt;&gt;(); map.put(\"user\",user); View view=new InternalResourceView(\"/test001.jsp\"); ModelAndView modelAndView=new ModelAndView(view,map); return modelAndView; } //第七种方式 @RequestMapping(\"/modelandview7\") public ModelAndView modelAndView7(){ User user=new User(); user.setId(1L); user.setName(\"张三\"); ModelAndView modelAndView=new ModelAndView(\"test001\",\"user\",user); return modelAndView; } //第八种方式 @RequestMapping(\"/modelandview8\") public ModelAndView modelAndView8(){ User user=new User(); user.setId(1L); user.setName(\"张三\"); View view=new InternalResourceView(\"/test001.jsp\"); ModelAndView modelAndView=new ModelAndView(view,\"user\",user); return modelAndView; }} HttpServletRequest 123456789101112@Controller@RequestMapping(\"/data\")public class RequestTestHandler { @RequestMapping(\"/request\") public String request(HttpServletRequest request){ User user = new User(); user.setId(1L); user.setName(\"张三\"); request.setAttribute(\"user\",user); return \"test001\"; }} 注意：使用HttpServletRequest 类需要导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt; @ModelAttribute 定义一个方法，该方法专门用来返回要填充到模型数据中的对象 12345678//第一种@ModelAttributepublic User getUser(){ User user = new User(); user.setId(1L); user.setName(\"张三\"); return user;} 12345678//第二种@ModelAttributepublic void getUser(Map&lt;String,User&gt; map){ User user = new User(); user.setId(2); user.setName(\"李四\"); map.put(\"user\",user);} 12345678//第三种@ModelAttributepublic void getUser(Model model){ User user = new User(); user.setId(3); user.setName(\"王五\"); model.addAttribute(\"user\",user);} 业务方法中无需再处理模型数据，只需返回视图即可 1234@RequestMapping(\"/modelAttribute\") public String modelAttribute(){ return \"test001\";} 将模型数据绑定到session对象 直接使用原生的Servlet API 1234567891011121314@Controller@RequestMapping(\"/data\")public class SessionTestHandler { @RequestMapping(\"/session\") public String session(HttpServletRequest request){ HttpSession session=request.getSession(); User user=new User(); user.setId(1L); user.setName(\"张三\"); session.setAttribute(\"user\",user); return \"test001\"; }} or 12345678910111213@Controller@RequestMapping(\"/data\")public class SessionTestHandler { @RequestMapping(\"/session2\") public String session2(HttpSession session){ User user = new User(); user.setId(1L); user.setName(\"张三\"); session.setAttribute(\"user\",user); return \"view\"; }} 使用@SessionAttribute 1234567891011121314@Controller@RequestMapping(\"/data\")@SessionAttributes(value={\"user\",\"student\"})public class ViewHandler { @RequestMapping(\"/session3\") public String session2(HttpSession session){ User user = new User(); user.setId(1L); user.setName(\"张三\"); session.setAttribute(\"user\",user); return \"test001\"; }} 对于 ViewHandler 中的所有业务方法，只要向 request 中添加了 key = &quot;user&quot;或key = “address” 的对象时，Spring MVC 会自动将该数据添加到 session 中，保存 key 不变 123@SessionAttributes(types = {User.class,Address.class})public class ViewHandler {} 对于 ViewHandler 中的所有业务方法，只要向 request 中添加了数据类型是 User 、Address 的对象时，Spring MVC 会自动将该数据添加到 session 中，保存key 不变 123@SessionAttributes(name = {\"user\",\"student\")public class ViewHandler {} 对于 ViewHandler 中的所有业务方法，只要向 request 中添加了value=&quot;user&quot;或value=“student”的对象时，Spring MVC 会自动将该数据添加到 session 中，保存key 不变 将数据模型绑定到application对象 123456789@RequestMapping(\"/application\")public String application(HttpServletRequest request){ ServletContext application = request.getServletContext(); User user = new User(); user.setId(1L); user.setName(\"张三\"); application.setAttribute(\"user\",user); return \"test001\";}","link":"/2019/04/08/Spring-MVC%E5%AD%A6%E4%B9%A0%E4%BA%8C/"},{"title":"Spring学习","text":"概述 Spring 是一个企业级开发框架，是软件设计层面的框架，优势在于可以将应用程序进行分层，开发者可以自主选择组件。 MVC：Struts2、Spring MVC ORMapping：Hibernate、MyBatis、Spring Data Spring的优点： 低侵入式设计 独立于各种应用服务器 依赖注入特性将组件关系透明化，降低了耦合度 面向切面编程特性允许将通用任务进行集中式处理 与第三方框架的良好整合 Spring 框架两大核心机制（IoC、AOP） IoC : Inversion of Control（控制反转）/DI : Dependency Injection (依赖注入) AOP :Aspect Oriented Programming（面向切面编程） IoC 在传统的程序开发中，需要调用对象时，通常由调用者来创建被调用者的实例，即对象是由调用者主动new出来的。 12345Student student = new Student();student.setId(1L);student.setName(\"张三\");student.setAge(22);System.out.println(student); 但是在Spring框架中创建对象的工作不再由调用者来完成，而是交给IoC容器来创建，在推送给调用者，整个流程完成反转，所以是控制反转。 （为了解耦合） 使用 在pom.xml中添加依赖 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建实体类 12345678910package com.litao.entity;import lombok.Data;@Datapublic class Student { private long id; private String name; private int age;} 通过IoC创建对象，在Xml 格式的配置文件中添加需要管理的对象，文件名可以自定义 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\"&gt; &lt;bean id=\"student\" class=\"com.litao.entity.Student\"&gt; &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"22\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 从IoC中通过 id 获取对象 1234ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\");//加载配置文件Student student = (Student) applicationContext.getBean(\"student\");System.out.println(student); 通过运行时类获取对象 123ApplicationContext applicationContext=new ClassPathXmlApplicationContext(\"Spring.xml\");Student student=(Student)applicationContext.getbean(\"Student.class\");System.out.println(student); 这种方式存在一个问题，配置文件中一个数据类型只能有一个实例 配置文件 通过配置 bean 标签完成对象的管理 id ：对象名 class ：对象的模板类（所有交给IoC容器来管理的类必须有无参构造函数，因为Spring底层是通过反射机制来创建对象，会调用类的无参构造函数） 对象的成员变量通过 property标签来完成赋值 name ：成员变量名 value ：成员变量值（基本数据类型，String可以直接赋值，如果是其它引用类型，不能通过value赋值） ref： 将IoC中的另外一个bean 赋给当前的成员变量（DI） 1234567891011&lt;bean id=\"student\" class=\"com.litao.entity.Student\"&gt; &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"22\"&gt;&lt;/property&gt; &lt;property name=\"address\" ref=\"address\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"address\" class=\"com.litao.entity.Address\"&gt; &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"上海\"&gt;&lt;/property&gt;&lt;/bean&gt; IoC底层原理 读取配置文件，解析xml (dom4j) 通过反射机制实例化配置文件中所有的bean 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.litao.ioc;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.HashMap;import java.util.Iterator;import java.util.Map;public class ClassPathXmlApplicationContext implements ApplicationContext { private Map&lt;String,Object&gt; ioc = new HashMap&lt;String, Object&gt;(); public ClassPathXmlApplicationContext(String path){ try { SAXReader reader = new SAXReader(); Document document = reader.read(\"./src/main/resources/\"+path); Element root = document.getRootElement(); Iterator&lt;Element&gt; iterator = root.elementIterator(); while(iterator.hasNext()){ Element element = iterator.next(); String id = element.attributeValue(\"id\"); String className = element.attributeValue(\"class\"); //通过反射机制创建对象 Class clazz = Class.forName(className); //获取无参构造函数，创建目标对象 Constructor constructor = clazz.getConstructor(); Object object = constructor.newInstance(); //给目标对象赋值 Iterator&lt;Element&gt; beanIter = element.elementIterator(); while(beanIter.hasNext()){ Element property = beanIter.next(); String name = property.attributeValue(\"name\"); String valueStr = property.attributeValue(\"value\"); String ref = property.attributeValue(\"ref\"); if(ref == null){ String methodName = \"set\"+name.substring(0,1).toUpperCase()+name.substring(1); Field field = clazz.getDeclaredField(name); Method method = clazz.getDeclaredMethod(methodName,field.getType()); //根据成员变量的数据类型将 value 进行转换 Object value = null; if(field.getType().getName() == \"long\"){ value = Long.parseLong(valueStr); } if(field.getType().getName() == \"java.lang.String\"){ value = valueStr; } if(field.getType().getName() == \"int\"){ value = Integer.parseInt(valueStr); } method.invoke(object,value); } ioc.put(id,object); } } } catch (DocumentException e) { e.printStackTrace(); } catch (ClassNotFoundException e){ e.printStackTrace(); } catch (NoSuchMethodException e){ e.printStackTrace(); } catch (InstantiationException e){ e.printStackTrace(); } catch (IllegalAccessException e){ e.printStackTrace(); } catch (InvocationTargetException e){ e.printStackTrace(); } catch (NoSuchFieldException e){ e.printStackTrace(); } } public Object getBean(String id) { return ioc.get(id); }} 通过有参构造创建bean 在实体类中创建对应的有参构造函数 配置文件 123456&lt;bean id=\"student3\" class=\"com.litao.entity.Student\"&gt; &lt;constructor-arg name=\"id\" value=\"3\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"name\" value=\"小明\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"age\" value=\"18\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"address\" ref=\"address\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; name属性也可用 index 属性替代，index=“0” ,表示有参构造参数的下标 给bean注入集合 123456789101112131415161718192021&lt;bean id=\"student\" class=\"com.litao.entity.Student\"&gt; &lt;property name=\"id\" value=\"2\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"李四\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"33\"&gt;&lt;/property&gt; &lt;property name=\"addresses\"&gt; &lt;list&gt; &lt;ref bean=\"address\"&gt;&lt;/ref&gt; &lt;ref bean=\"address2\"&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"address\" class=\"com.litao.entity.Address\"&gt; &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"上海\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"address2\" class=\"com.litao.entity.Address\"&gt; &lt;property name=\"id\" value=\"2\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"北京\"&gt;&lt;/property&gt;&lt;/bean&gt; scope作用域 Spring管理的bean是根据scope来生成的，表示bean的作用域，一共4种，默认是singleton singleton：单例，表示通过IoC容器获取的beans是一种 prototype：原型，表示通过 IoC 容器获取的 bean 是不同的 request：请求，表示在一次 HTTP 请求内有效 session：回话，表示在一个用户会话内有效。 request 和 session 只适用于 Web 项目，大多数情况下，使用单例和原型较多。 prototype 模式当业务代码获取 IoC 容器中的 bean 时，Spring 才去调用无参构造创建对应的 bean。 singleton 模式无论业务代码是否获取 IoC 容器中的 bean，Spring 在加载 spring.xml 时就会创建 bean。 Spring的继承 与 Java 的继承不同，Java 是类层面的继承，子类可以继承父类的内部结构信息；Spring 是对象层面的继承，子对象可以继承父对象的属性值。 Spring 的继承关注点在于具体的对象，而不在于类，即不同的两个类的实例化对象可以完成继承，前提是子对象必须包含父对象的所有属性，同时可以在此基础上添加其他的属性。 12345678910111213141516171819202122232425&lt;bean id=\"student2\" class=\"com.litao.entity.Student\"&gt; &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"22\"&gt;&lt;/property&gt; &lt;property name=\"addresses\"&gt; &lt;list&gt; &lt;ref bean=\"address\"&gt;&lt;/ref&gt; &lt;ref bean=\"address2\"&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"address\" class=\"com.litao.entity.Address\"&gt; &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"上海\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"address2\" class=\"com.litao.entity.Address\"&gt; &lt;property name=\"id\" value=\"2\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"北京\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"stu\" class=\"com.litao.entity.Student\" parent=\"student2\"&gt; &lt;property name=\"name\" value=\"李四\"&gt;&lt;/property&gt;&lt;/bean&gt; Spring的依赖 与继承类似，依赖也是描述 bean 和 bean 之间的一种关系，配置依赖之后，被依赖的 bean 一定先创建，再创建依赖的 bean。例如，B 依赖于 A，先创建 A，再创建 B。 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd \"&gt; &lt;bean id=\"student\" class=\"com.litao.entity.Student\" depends-on=\"address\"&gt; &lt;/bean&gt; &lt;bean id=\"address\" class=\"com.litao.entity.Address\"&gt; &lt;/bean&gt;&lt;/beans&gt; Spring的P命名空间 p 命名空间是对 IoC / DI 的简化操作，使用 p 命名空间可以更加方便的完成 bean 的配置以及 bean 之间的依赖注入。 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\"&gt; &lt;bean id=\"student\" class=\"com.litao.entity.Student\" p:id=\"1\" p:name=\"张三\" p:age=\"22\" p:address-ref=\"address\"&gt;&lt;/bean&gt; &lt;bean id=\"address\" class=\"com.litao.entity.Address\" p:id=\"2\" p:name=\"上海\"&gt;&lt;/bean&gt;&lt;/beans&gt; Spring工厂方法 IoC 通过工厂模式创建 bean 的方式有两种： 静态工厂方法 实例工厂方法 静态工厂方法 实体类 12345678910111213package com.litao.entity;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Car { private long id; private String name;} 静态工厂类 12345678910111213141516171819package com.litao.factory;import com.litao.entity.Car;import java.util.HashMap;import java.util.Map;public class StaticCarFactory { private static Map&lt;Long, Car&gt; carMap; static{ carMap = new HashMap&lt;Long, Car&gt;(); carMap.put(1L,new Car(1L,\"宝马\")); carMap.put(2L,new Car(2L,\"奔驰\")); } public static Car getCar(long id){ return carMap.get(id); }} 配置静态工厂 1234&lt;!-- 配置静态工厂创建 Car --&gt;&lt;bean id=\"car\" class=\"com.litao.factory.StaticCarFactory\" factory-method=\"getCar\"&gt; &lt;constructor-arg value=\"2\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 实例工厂方法 12345678910111213141516171819package com.litao.factory;import com.litao.entity.Car;import java.util.HashMap;import java.util.Map;public class InstanceCarFactory { private Map&lt;Long, Car&gt; carMap; public InstanceCarFactory(){ carMap = new HashMap&lt;Long, Car&gt;(); carMap.put(1L,new Car(1L,\"宝马\")); carMap.put(2L,new Car(2L,\"奔驰\")); } public Car getCar(long id){ return carMap.get(id); }} 配置实例工厂 1234567&lt;!-- 配置实例工厂 bean --&gt;&lt;bean id=\"carFactory\" class=\"com.litao.factory.InstanceCarFactory\"&gt;&lt;/bean&gt;&lt;!-- 配置实例工厂创建 Car --&gt;&lt;bean id=\"car2\" factory-bean=\"carFactory\" factory-method=\"getCar\"&gt; &lt;constructor-arg value=\"1\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; IoC自动装载（Autowire） IoC 负责创建对象，DI 负责完成对象的依赖注入，通过配置 property 标签的 ref 属性来完成，同时 Spring 提供了另外一种更加简便的依赖注入方式：自动装载，不需要手动配置 property，IoC 容器会自动选择 bean 完成注入。 自动装载有两种方式： byName：通过属性名自动装载 byType：通过属性的数据类型自动装载 byName 123456789101112131415package com.litao.entity;import com.litao.entity.Car;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Person { private long id; private String name; private Car cars;} 123456789&lt;bean id=\"cars\" class=\"com.litao.entity.Car\"&gt; &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"宝马\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"person\" class=\"com.litao.entity.Person\" autowire=\"byName\"&gt; &lt;property name=\"id\" value=\"11\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt;&lt;/bean&gt; byType 123456789&lt;bean id=\"car\" class=\"com.southwind.entity.Car\"&gt; &lt;property name=\"id\" value=\"2\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"奔驰\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"person\" class=\"com.southwind.entity.Person\" autowire=\"byType\"&gt; &lt;property name=\"id\" value=\"11\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt;&lt;/bean&gt; byType 需要注意，如果同时存在两个及以上的符合条件的 bean 时，自动装载会抛出异常。 AOP AOP：Aspect Oriented Programming 面向切面编程。 AOP 的优点： 降低模块之间的耦合度。 使系统更容易扩展。 更好的代码复用。 非业务代码更加集中，不分散，便于统一管理。 业务代码更加简洁存粹，不参杂其他代码的影响。 AOP 是对面向对象编程的一个补充，在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面编程。将不同方法的同一个位置抽象成一个切面对象，对该切面对象进行编程就 例子 在pom.xml中导入依赖 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.0.11.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.0.11.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建一个计算器接口 Cal，定义4个方法 123456public interface Cal { public int add(int num1,int num2); public int sub(int num1,int num2); public int mul(int num1,int num2); public int div(int num1,int num2);} 创建接口的实现类 CalImpl 1234567891011121314151617181920212223242526272829public class CalImpl implements Cal { public int add(int num1, int num2) { System.out.println(\"add方法的参数是[\"+num1+\",\"+num2+\"]\"); int result = num1+num2; System.out.println(\"add方法的结果是\"+result); return result; } public int sub(int num1, int num2) { System.out.println(\"sub方法的参数是[\"+num1+\",\"+num2+\"]\"); int result = num1-num2; System.out.println(\"sub方法的结果是\"+result); return result; } public int mul(int num1, int num2) { System.out.println(\"mul方法的参数是[\"+num1+\",\"+num2+\"]\"); int result = num1*num2; System.out.println(\"mul方法的结果是\"+result); return result; } public int div(int num1, int num2) { System.out.println(\"div方法的参数是[\"+num1+\",\"+num2+\"]\"); int result = num1/num2; System.out.println(\"div方法的结果是\"+result); return result; }} 上述代码中，日志信息和业务逻辑的耦合性很高，不利于系统的维护，使用 AOP 可以进行优化。使用动态代理的方式来实现AOP。 给业务代码找一个代理，打印日志信息的工作交个代理来做，这样的话业务代码就只需要关注自身的业务即可。 12345678910111213141516171819202122import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays;public class MyInvocationHandler implements InvocationHandler { //接收委托对象 private Object object = null; //返回代理对象 public Object bind(Object object){ this.object = object; return Proxy.newProxyInstance(object.getClass().getClassLoader(),object.getClass().getInterfaces(),this); } public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method.getName()+\"方法的参数是：\"+ Arrays.toString(args)); Object result = method.invoke(this.object,args); System.out.println(method.getName()+\"的结果是\"+result); return result; }} 以上是通过动态代理实现 AOP 的过程，比较复杂。Spring 框架对 AOP 进行了封装，使用 Spring 框架可以用面向对象的思想来实现 AOP。 Spring 框架中不需要创建 InvocationHandler，只需要创建一个切面对象，将所有的非业务代码在切面对象中完成即可，Spring 框架底层会自动根据切面类以及目标类生成一个代理对象。 1234567891011121314151617181920212223242526272829303132333435363738394041import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import java.util.Arrays;@Aspect@Componentpublic class LoggerAspect { @Before(value = \"execution(public int com.litao.utils.impl.CalImpl.*(..))\") public void before(JoinPoint joinPoint){ //获取方法名 String name = joinPoint.getSignature().getName(); //获取参数 String args = Arrays.toString(joinPoint.getArgs()); System.out.println(name+\"方法的参数是：\"+ args); } @After(value = \"execution(public int com.litao.utils.impl.CalImpl.*(..))\") public void after(JoinPoint joinPoint){ //获取方法名 String name = joinPoint.getSignature().getName(); System.out.println(name+\"方法执行完毕\"); } @AfterReturning(value = \"execution(public int com.litao.utils.impl.CalImpl.*(..))\",returning = \"result\") public void afterReturning(JoinPoint joinPoint,Object result){ //获取方法名 String name = joinPoint.getSignature().getName(); System.out.println(name+\"方法的结果是\"+result); } @AfterThrowing(value = \"execution(public int com.litao.utils.impl.CalImpl.*(..))\",throwing = \"exception\") public void afterThrowing(JoinPoint joinPoint,Exception exception){ //获取方法名 String name = joinPoint.getSignature().getName(); System.out.println(name+\"方法抛出异常：\"+exception); }} 类定义处添加的两个注解： @Aspect：表示该类是切面类。 @Component：将该类的对象注入到 IoC 容器。 CalImpl 也需要添加 @Component，交给 IoC 容器来管理。 具体方法处添加的注解： @Before：表示方法执行的具体位置和时机。 spring.xml 中配置 AOP 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\"&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package=\"com.litao\"&gt;&lt;/context:component-scan&gt; &lt;!-- 使Aspect注解生效，为目标类自动生成代理对象 --&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt; context:component-scan 将 com.litao 包中的所有类进行扫描，如果该类同时添加了 @Component`，则将该类扫描到 IoC 容器中，即 IoC 管理它的对象。 aop:aspectj-autoproxy 让 Spring 框架结合切面类和目标类自动生成动态代理对象。 切面：横切关注点被模块化的抽象对象。 通知：切面对象完成的工作。 目标：被通知的对象，即被横切的对象。 代理：切面、通知、目标混合之后的对象。 连接点：通知要插入业务代码的具体位置。 切点：AOP 通过切点定位到连接点。","link":"/2019/04/05/Spring%E5%AD%A6%E4%B9%A0/"},{"title":"c3p0连接池","text":"概述 数据库连接对象是通过DriverManager来获取的，每次获取都需要向数据库获取数据连接，验证用户名和密码，执行完SQL语句断开连接，这样的方式会造成资源的浪费，数据资源没有得到很好的重复利用。可以使用数据库连接池解决该问题。 数据库连接池的基本思想就是为数据库建立一个缓冲池，预先向缓冲池放入一定数量的连接对象，当需要获取数据库连接的时候，只需要从缓冲池取出一个对象，用完之后再放回缓冲池中，供下一次请求使用，做到了资源的重复利用，允许程序重复使用一个现有的数据库连接对象，而不需要重新创建。 当数据库连接池没有空闲的连接时，新的请求就会进入等待队列，等待其他线程释放连接。 c3p0连接池实现 JDBC的数据库连接池使用javax.sql.DataSource接口来完成的，DataSource是Java官方提供的的接口，使用的时候开发者不需要自己来实现该接口，可以使用第三方的工具，如c3p0，DBCP，Druid，HikariCP。 传统方式得到的Connection 1com.mysql.cj.jdbc.ConnectionImpl@557caf28 c3p0得到的Connection 1com.mchange.v2.c3p0.impl.NewProxyConnection@4988d8b8 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt;&lt;/dependency&gt; 使用 12345678910111213141516171819202122232425262728package com.litao.test;import com.mchange.v2.c3p0.ComboPooledDataSource;import java.beans.PropertyVetoException;import java.sql.Connection;import java.sql.SQLException;public class DataSourceTest { public static void main(String[] args) { try { //创建C3P0 ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(\"com.mysql.cj.jdbc.Driver\"); dataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/test? useUnicode=true&amp;characterEncoding=UTF-8\"); dataSource.setUser(\"root\"); dataSource.setPassword(\"li980616\"); Connection connection = dataSource.getConnection(); System.out.println(connection); //还回到数据库连接池中 connection.close(); } catch (PropertyVetoException e) { e.printStackTrace(); } catch (SQLException e){ e.printStackTrace(); } }} 实际开发，将 c3p0 的配置信息定义在 xml文件中，Java程序只需要加载配置⽂件即可完成数据库连接池的初始化操作。 配置文件的名字必须是c3p0-config.xml 初始化ComblPooledDataSource时，传入的参数必须是c3p0-config.xml中named-config标签的name属性值 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;c3p0-config&gt; &lt;named-config name=\"testc3p0\"&gt; &lt;!-- 指定连接数据源的基本属性--&gt; &lt;property name=\"driverClass\"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=\"user\"&gt;root&lt;/property&gt; &lt;property name=\"password\"&gt;li980616&lt;/property&gt; &lt;property name=\"jdbcUrl\"&gt;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;amp;character=UTF-8&lt;/property&gt; &lt;!--如数据库中连接数不足时，一次向数据库服务器申请多少个连接--&gt; &lt;property name=\"acquireIncrement\"&gt;5&lt;/property&gt; &lt;property name=\"initialPoolSize\"&gt;20&lt;/property&gt; &lt;property name=\"minPoolSize\"&gt;2&lt;/property&gt; &lt;property name=\"maxPoolSize\"&gt;40&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 123456789101112131415161718192021package com.litao.test;import com.mchange.v2.c3p0.ComboPooledDataSource;import java.beans.PropertyVetoException;import java.sql.Connection;import java.sql.SQLException;public class DataSourceTest { public static void main(String[] args) { try { //创建C3P0 ComboPooledDataSource dataSource = new ComboPooledDataSource(\"testc3p0\"); Connection connection = dataSource.getConnection(); System.out.println(connection); //还回到数据库连接池中 connection.close(); } catch (SQLException e){ e.printStackTrace(); } }} 可以另外再创建一个JDBCTools类来获取数据库连接池对象,之后就可以通过getConnection方法来获取连接池对象，通过release方法来释放对象 12345678910111213141516171819202122232425262728293031323334353637383940public class JDBCTools { private static DataSource dataSource; static { dataSource=new ComboPooledDataSource(\"testc3p0\"); } private static Connection getConneciton(){ Connection connection=null; try { connection=dataSource.getConnection(); } catch (SQLException e) { e.printStackTrace(); } return connection; } private static void release(Connection connection, Statement statement, ResultSet resultSet){ try { if(connection!=null){ connection.close(); } if (statement!=null){ statement.close(); } if(resultSet!=null){ resultSet.close(); } } catch (SQLException e) { e.printStackTrace(); } } //测试连接 //public static void main(String[] args) { // System.out.println(JDBCTools.getConneciton()); // }} DBUtils DBUtils可以帮助开发者完成数据的封装（结果集到Java对象的映射） 使用 导入依赖 12345 &lt;dependency&gt; &lt;groupId&gt;commons‐dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons‐dbutils&lt;/artifactId&gt; &lt;version&gt;1.6&lt;/version&gt;&lt;/dependency&gt; ResultHandler 接口是用来处理结果集，可以将查询到的结果集转换成Java对象，提供4种实现类 BeanHandler 将结果集映射成 Java 对象 BeanListHandler 将结果集映射成 List 集合 MapHandler 将结果集映射成 Map 对象 MapListHandler 将结果集映射成 MapList 结合 1234567891011121314151617181920212223public static Student findByDBUtils(Integer id){ Connection connection = null; Student student = null; try { connection = dataSource.getConnection(); String sql = \"select * from student\"; QueryRunner queryRunner = new QueryRunner(); List&lt;Map&lt;String,Object&gt;&gt; list = queryRunner.query(connection,sql,new MapListHandler()); for (Map&lt;String,Object&gt; map:list){ System.out.println(map); } } catch (SQLException e) { e.printStackTrace(); } finally { try { connection.close(); } catch (SQLException e) e.printStackTrace(); } } return student;} QueryRunner核心类 update（Connection conn, String sql, Object… params) 执行insert，update，delete操作 query（Connection conn, String sql, ResultSetHandler rsh, Object… params）用来完成表数据的查询操作","link":"/2019/02/21/c3p0%E8%BF%9E%E6%8E%A5%E6%B1%A0/"},{"title":"Spring MVC学习三","text":"Spring MVC 自定义数据转换器 数据转换器是指将客户端 HTTP 请求中的参数转换为业务方法中定义的形参，自定义表示开发者可以自主设计转换的方式，HandlerApdter 已经提供了通用的转换，如String 转 int，String 转 double，表单数据的封装等，但是在特殊的业务场景下，HandlerAdapter 无法进行转换，就需要开发者自定义转换器。 案例 客户端输入String类型的数据“2019-4-09”，自定义转换器将该数据转为Date类型的对象 创建DateContverter转换器，实现Conveter 1","link":"/2019/04/09/Spring-MVC%E5%AD%A6%E4%B9%A0%E4%B8%89/"}],"tags":[{"name":"Mysql","slug":"Mysql","link":"/tags/Mysql/"},{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"JDBC","slug":"JDBC","link":"/tags/JDBC/"},{"name":"MyBatis","slug":"MyBatis","link":"/tags/MyBatis/"},{"name":"Servlet Jsp","slug":"Servlet-Jsp","link":"/tags/Servlet-Jsp/"},{"name":"Spring MVC","slug":"Spring-MVC","link":"/tags/Spring-MVC/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"数据库连接池","slug":"数据库连接池","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"}],"categories":[{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Java Web","slug":"Java-Web","link":"/categories/Java-Web/"}]}
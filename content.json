{"pages":[{"title":"about","text":"个人博客，仅供学习","link":"/about/index.html"}],"posts":[{"title":"IDEA中lombok插件离线安装","text":"因为网络问题，安装lombok一直失败，所以这次采用插件包离线安装 下载插件包，插件包有两个地方可以下载，分别是IDEA的官方插件仓库和GitHub里lombok-intellij-plugin仓库 IDEA：http://plugins.jetbrains.com/plugin/6317-lombok-plugin Github：https://github.com/mplushnikov/lombok-intellij-plugin/releases 我这里采用Github仓库的 对照自己下载的IDEA版本下载指定的插件包 文件下载 不清楚自己IDEA的，可依次进入IDEA-----&gt; Help —&gt;About查看 安装插件包 依次进入IDEA —&gt; Settings -----&gt;Plugins 点击第三个选项，找到刚才下载的lombok插件包的位置进行安装，完成后重启IDEA 这样就安装完成了 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt;&lt;/dependency&gt;","link":"/2020/02/17/IDEA%E4%B8%ADlombok%E6%8F%92%E4%BB%B6%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85/"},{"title":"DataGrip连接Mysql错误之时区错误","text":"操作系统: win 10 Mysql 版本 : 8.0 错误描述 在DataGrip中连接Mysql时，发生如下错误: 原因:在使用Mysql的6.0.x以上的jar的时候，需要指定serverTimezone,否则就会出现异常。 解决方法 方法一：命令行登录MySql修改Mysql 时区 这种方法不推荐，因为当Mysql服务重启的时候，被修改的时区时间会被重置，下次连接Mysql时问 题依然会存在。 配置Mysql环境变量 编辑Path，加入Mysql的bin路径 命令行登录Mysql mysql -u root -p '你的密码' 查看并修改时区 show variables like ``'%time_zone%'; ​ Mysql默认SYSTEM是美国时间，比我国晚8个小时 ​ set global time_zone = ``'+8:00'``; ​ 修改后，重新用DataGrip重新连接，问题解决。 方法二: 修改database配置中的serverTimezone 设置serverTimezone 为UTC (世界协调时间) 再次连接 使用IDEA内置的数据库管理工具时，如果遇到时区问题，也可用这种方法解决","link":"/2019/05/16/DataGrip%E8%BF%9E%E6%8E%A5Mysql%E9%94%99%E8%AF%AF%E4%B9%8B%E6%97%B6%E5%8C%BA%E9%94%99%E8%AF%AF/"},{"title":"Intellij IDEA 安装","text":"操作系统: win10 1.IDEA介绍 IDEA全称IntelliJ IDEA（JetBrains公司旗下的产品），是Java编程语言开发的集成境。“Capable and Ergonomic IDE for JVM” 官网,适用于JVM的功能强大且符合人体工程学(Human Engineering)的IDE（Integrated Development Environment-集成开发环境） 2. 下载并安装 网址 : https://www.jetbrains.com/idea/ 进行安装 ​ 一直点击next完成安装 3.目录结构 bin:容器，执行文件和启动参数等 help：快捷键文档和其它帮助文档 jbr:??? lib:IDEA依赖的类库 license：各个插件许可 plugins: IDEA插件 redist:??? bin目录下： idea.properties :IDEA配置文件 idea64.exe.vmoptions ：64位idea vm配置文件 vm配置文件 -Xms128m : 设置初始的内存数，提高该值可以加快Java程序的启动速度（16内存好像可以尝试改为-Xms512m） -Xmx1010m :设置最大内存数，提高该值，可以减少内存Garage收集的频率，提高程序性能（16内存好像可以尝试改为-Xmx1500m） -XX:ReservedCodeCacheSize=240m ：保留代码占用的内存容量（16G 内存的机器可尝试设置为500m） 设置目录（C盘用户文件下） 这是IDEA保存各种配置的目录。 这个设置目录有一个特性，就是你删除掉整个目录之 后，重新启动 IntelliJ IDEA 会再自动帮你生成一个全新的默认配置，所以很多时候如果你把 IntelliJ IDEA 配置改乱了，只要删掉该目录，一切都会还原到默认。 有两个是因为我下过两个版本的IDEA，老版本的配置我没有删掉 config：该目录是IDEA 个性化化配置目录，或者说是整个 IDE 设置目录。安装新版本的 IntelliJ IDEA 时会自动扫描硬盘上的旧配置目录，被扫描的目录指的就是该目录。这个目录主要记录了IDEA 主要配置功能、自定义的代码模板、自定义的文件模板、自定义的快捷键、 Project 的 tasks 记录等个性化的设置。 system : 该目录是IDEA系统文件目录，是 IDEA 与开发项目一个桥梁目录，里面主要有：缓存、索引、容器文件输出等 4. 这里推荐一款IDEA编辑字体(jetbrains mono) 字体样例: 下载步骤 官方网址: https://www.jetbrains.com/lp/mono/ 点击 右上角下载 下载完成后，解压，进入ttf文件夹 逐一双击进行安装 字体样式安装完后，打开IDEA，依次进入file ----&gt;Settings —&gt;Editor ----&gt;Font 进行设置","link":"/2020/02/17/Intellij-IDEA-%E5%AE%89%E8%A3%85/"},{"title":"MyBatis框架学习一","text":"mysql : 8.0 概述 持久层技术解决方案： JDBC技术： Connection PreparedStatement ResultSet Spring的JdbcTemplate: Spring中对jdbc的封装 Apache的DButils： 与Spring的JdbcTemplate很像，也是对Jdbc的封装 以上这些都不是框架，JDBC是规范，Spring的JdbcTemplate和Apache的DButils都只是工具类 MyBatis框架概述： Mybatis是apache的一个开源项目iBatis，2010年这个项目由apache software foundation迁移到了google code，并且改名为Mybatis，2013年迁移到Github Mybatis是一个数据持久化的开源框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建链接、创建statement等过程。 mybatis可通过xml或注解的方式将要执行的statement语句配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。 采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，是我们不用与Jdbc api打交道，就可以完成对数据库的持久化操作。 创建Mysql用户测试表 12345678create table user( id int(10) not null auto_increment, username varchar(30) not null comment '用户名称', birthday datetime default null comment '生日', sex char(1) default null comment '性别', address varchar(100) default null comment '地址', primary key (id))ENGINE =InnoDB DEFAULT CHARSET =utf8; 插入数据 环境配置 导入依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.15&lt;/version&gt;&lt;/dependency&gt; 创建实体类的接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.io.Serializable;import java.util.Date;public class User implements Serializable { private static final long serialVersionUID=1L; private Integer id; private String username; private Date birthday; private String sex; private String address; public static long getSerialVersionUID() { return serialVersionUID; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Date getBirthday() { return birthday; } public void setBirthday(Date birthday) { this.birthday = birthday; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public User(Integer id, String username, Date birthday, String sex, String address) { this.id = id; this.username = username; this.birthday = birthday; this.sex = sex; this.address = address; } public User() { } @Override public String toString() { return \"User{\" + \"id=\" + id + \", username='\" + username + '\\'' + \", birthday=\" + birthday + \", sex='\" + sex + '\\'' + \", address='\" + address + '\\'' + '}'; }} 在resource文件下创建Mybatis的主配置文件 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!--mybatis主配置文件--&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default=\"mysql\"&gt; &lt;!--配置mysql的环境--&gt; &lt;environment id=\"mysql\"&gt; &lt;!--配置事务的类型--&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!--配置连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--配置连接数据库的基本信息--&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test_mybatis?useUnicode=true&amp;amp;character=UTF-8&amp;amp;serverTimezone=UTC\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"li980616\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 通过Mapper代理实现自定义接口 自定义接口 1234567public interface UserRepository { public int save(User user); public int update(Integer id,User user); public int deleteById(Integer id); public List&lt;User&gt; findall(); public User findById(Integer id);} 创建接口对应的Mapper.xml，定义接口方法对应的Sql语句 statement标签可根据sql执行的业务选择insert，delete，update，select Mybatis框架会根据规则自动创建接口实现类的代理对象。 规则： XXXMapper.xml中namespace为接口的全类名 XXXMapper.xml中statement的id为接口中对应的方法名 XXXMapper.xml中statement的parameterType和接口中对应方法的参数类型一致 XXXMapper.xml中statement的resultType和接口中对应的方法的返回值类型要一致 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.UserRepository\"&gt; &lt;!-- 插入数据--&gt; &lt;insert id=\"save\" parameterType=\"com.litao.entity.User\"&gt; insert into user(username,birthday,sex,address) values(#{username},#{birthday},#{sex},#{address}) &lt;/insert&gt; &lt;!-- 修改数据--&gt; &lt;update id=\"update\"&gt; update user set username=#{param2.username},birthday=#{param2.birthday},sex=#{param2.sex},address=#{param2.address} where id=#{param1} &lt;/update&gt; &lt;!--根据id删除数据--&gt; &lt;delete id=\"deleteById\" parameterType=\"Integer\"&gt; delete from user where id=#{id} &lt;/delete&gt; &lt;!--查询所有--&gt; &lt;select id=\"findall\" resultType=\"com.litao.entity.User\"&gt; select * from user &lt;/select&gt; &lt;!--根据id查询数据--&gt; &lt;select id=\"findById\" parameterType=\"Integer\" resultType=\"com.litao.entity.User\"&gt; select * from user where id=#{id} &lt;/select&gt;&lt;/mapper&gt; 注意事项 在Mybatis中把持久层的操作接口和映射文件也叫做 Mapper，所以UserRespository和UserMapper是一样的 上述操作和注意事项完成后，开发中无需再写接口的实现类 在Mybatis的主配置文件注册UserRepository.xml 123&lt;mappers&gt; &lt;mapper resource=\"com/litao/repository/UserRepository.xml\"/&gt;&lt;/mappers&gt;","link":"/2019/05/19/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B8%80/"},{"title":"JDBC学习","text":"概述 Java DataBase Connectivity 是一个独立于特定数据库的管理系统，通用的的SQL数据库存取和操作的公共接口。 定义了一组标准，为访问不同数据库提供了统一的途径。 JDBC体系结构 JDBC接口包含了两个层面: 面向应用的API，供程序员调用 面向数据库的API，供厂商开发数据库的驱动程序 JDBC API 提供者：Java官方 内容：供开发者调用的接口 java.sql 和 javax.sql DriverManager类 Connection接口 Statement 接口 ResultSet 接口 DriverManager 提供者：Java官方 作用：管理不同的JDBC驱动 JDBC 驱动 提供者：数据库厂商 作用：负责连接不同的数据库 JDBC开发流程 加载驱动（只需要加载一次） 建立数据库连接（Connection） 执行SQL语句（Statement） ResultSet接收结果集（查询） 断开连接，释放资源 使用 加载数据库驱动，Java程序和数据库之间的桥梁 获取Connection，Java程序与数据库的一次连接 创建Statement对象，由Connection产生，执行SQL语句 如果需要连接返回值，创建ResultSet对象，保存Statement执行之后所查询到的结果 123456789101112131415161718192021222324252627282930313233343536373839404142package com.litao.test;import java.sql.*;import java.util.Date;public class Test { public static void main(String[] args) { try { //加载驱动 Class.forName(\"com.mysql.cj.jdbc.Driver\"); //获取连接 String url = \"jdbc:mysql://localhost:3306/test? useUnicode=true&amp;characterEncoding=UTF-8\"; String user = \"root\"; String password = \"li980616\"; Connection connection = DriverManager.getConnection(url,user,password); // String sql = \"insert into student(name,score,birthday) values('李 四',78,'1999-01-01')\"; // String sql = \"update student set name = '李四'\"; // String sql = \"delete from student\"; // Statement statement = connection.createStatement(); // int result = statement.executeUpdate(sql); String sql = \"select * from student\"; Statement statement = connection.createStatement(); ResultSet resultSet = statement.executeQuery(sql); while (resultSet.next()){ Integer id = resultSet.getInt(\"id\"); String name = resultSet.getString(2); Double score = resultSet.getDouble(3); Date date = resultSet.getDate(4); System.out.println(id+\"-\"+name+\"-\"+score+\"-\"+date); } resultset.close(); connection.close(); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e){ e.printStackTrace(); } }} PreparedStatement Statement 的子类，提供了SQL占位符的功能 为何使用PreparedStatement 使用Statement进行开发有两个问题： 需要频繁拼接String 字符串，出错率高 存在SQL注入的风险 SQL注入：利用某些系统没有对用户输入的信息进行充分的检测，在用户输入的数据中注入非法的SQL语句，从而利用系统的SQL引擎完成恶意行为的做法。如 1select * from student where username='张三' or '1'='1' 使用 12345678910111213141516171819202122232425String url = \"jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8\";String user = \"root\";String password = \"li980616\";Connection connection = DriverManager.getConnection(url,user,password);String username = \"李四\";String mypassword = \"123\";String sql = \"select * from t_user where username = ? and password = ?\";System.out.println(sql);PreparedStatement preparedStatement = connection.prepareStatement(sql);preparedStatement.setString(1,username);preparedStatement.setString(2,mypassword);ResultSet resultSet = preparedStatement.executeQuery();if(resultSet.next()){ System.out.println(\"登录成功\");}else{ System.out.println(\"登录失败\");}resultset.close();connection.close();} catch (ClassNotFoundException e) { e.printStackTrace();} catch (SQLException e){ e.printStackTrace();}","link":"/2019/02/21/JDBC%E5%AD%A6%E4%B9%A0/"},{"title":"Mybatis框架学习三","text":"Mysql ：8.0 逆向工程 MyBatis框架需要：实体类、自定义Mapper接口、Mapper.xml 传统的开发中上述的三个组件需要开发者手动创建，逆向工程可以帮助开发者自动创建这三个组件，减轻工作量，提高工作效率。 缺点： 只能执行一次，多次执行会多次创建实体类 当表结构发生改变时，需要删除已生成的资源，再重新生成 使用 MyBatis Generator，简称MBG，是一个专门为Mybatis框架开发者定制的代码生成器，可自动生成Mybatis框架所需的实体类、Mapper接口、Mapper.xml，支持基本的CRUD操作，但开发者仍需要自己来完成一些复杂的sql。 引入依赖 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.15&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 创建MBG配置文件generatorConfig.xml jdbcConnection 配置数据库连接信息 javaModelGenerator配置JavaBean的生成策略 sqlMapGenerator配置SQL映射文件生成策略 javaClientGenerator配置Mapper接口的生成策略 table配置目标数据表 (tableName : 表名, dominObjectName ：JavaBean类名) 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;context id=\"testTables\" targetRuntime=\"MyBatis3\"&gt; &lt;jdbcConnection driverClass=\"com.mysql.cj.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/test_mybatis?useUnicode=true&amp;amp;character=UTF-8&amp;amp;serverTimezone=UTC\" userId=\"root\" password=\"li980616\" &gt;&lt;/jdbcConnection&gt; &lt;javaModelGenerator targetPackage=\"com.litao.entity\" targetProject=\"./src/main/java\"&gt;&lt;/javaModelGenerator&gt; &lt;sqlMapGenerator targetPackage=\"com.litao.repository\" targetProject=\"./src/main/java\"&gt;&lt;/sqlMapGenerator&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.litao.repository\" targetProject=\"./src/main/java\"&gt;&lt;/javaClientGenerator&gt; &lt;table tableName=\"user\" domainObjectName=\"User\"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 创建Generator执行类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.exception.InvalidConfigurationException;import org.mybatis.generator.exception.XMLParserException;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.io.IOException;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;public class Main { public static void main(String[] args) { List&lt;String&gt; warings=new ArrayList&lt;String&gt;(); boolean overwrite=true; String genCig=\"/generatorConfig.xml\"; File configFile=new File(Main.class.getResource(genCig).getFile()); ConfigurationParser configurationParser=new ConfigurationParser(warings); Configuration configuration=null; try { configuration=configurationParser.parseConfiguration(configFile); } catch (IOException e) { e.printStackTrace(); } catch (XMLParserException e) { e.printStackTrace(); } DefaultShellCallback callback=new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator=null; try { myBatisGenerator=new MyBatisGenerator(configuration,callback,warings); } catch (InvalidConfigurationException e) { e.printStackTrace(); } try { myBatisGenerator.generate(null); } catch (SQLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (InterruptedException e) { e.printStackTrace(); } }} MyBatis延迟加载 概念 延迟加载也叫懒加载、惰性加载，使用延迟加载可以提高程序的运行效率，针对于数据持久层的操作，在某些特定的情况下去访问特定的数据库，在其他情况下可以不访问某些表，从一定程度上减少了Java应用与数据库的交互次数。 查询学生和班级时，学生和班级是两个不同的表，如果当前需求只需要获取学生的信息，那只需要查询学生的单表即可，如果需要通过学生获取对应的班级信息，则必须查询两个表。 不同的业务需求，需要查询不同的表，根据具体的业务需求来动态减少数据表查询的工作就是延迟加载。 将多表关联查询拆分成多个单表查询 StudentRepository.xml 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.StudentRepository\"&gt;&lt;resultMap id=\"studentMap\" type=\"com.litao.entity.Student\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"name\" property=\"name\"&gt;&lt;/result&gt; &lt;association property=\"classes\" javaType=\"com.litao.entity.Classes\" select=\"com.litao.repository.ClassesRepository.findById\" column=\"cid\"&gt; &lt;/association&gt;&lt;/resultMap&gt; &lt;select id=\"findById\" parameterType=\"long\" resultMap=\"studentMap\"&gt; select * from student where id=#{id} &lt;/select&gt;&lt;/mapper&gt; ClassesRepository.xml 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.ClassesRepository\"&gt; &lt;resultMap id=\"classesMap\" type=\"com.litao.entity.Classes\"&gt; &lt;id column=\"cid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"cname\" property=\"name\"&gt;&lt;/result&gt; &lt;collection property=\"students\" ofType=\"com.litao.entity.Student\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findById\" parameterType=\"long\" resultType=\"com.litao.entity.Classes\"&gt; select * from classes where id=#{id} &lt;/select&gt;&lt;/mapper&gt; 开启延迟加载（Mybatis主配置文件中添加） 123456&lt;settings&gt; &lt;!-- 打印sql--&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;!--开启延迟加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt;&lt;/settings&gt; 对比 未开启延迟加载： 只查询学生的名字时，我们只需要查询student表即可完成，但实际上依然会同时查询student和classes两种表 开启延迟加载： 之查询学生名字时，只用查询student表，而不会再联动查询classes表 Mybatis缓存 什么是Mybatis缓存 使用缓存可以减少Java应用与数据库的交互次数，从而提升程序的运行效率。如查询出id=1的对象，第一次查询之后会自动将该对象保存到缓存中，当下一次查询时，直接从缓存中取出对象即可，无需再次访问数据库。 缓存分类 一级缓存：SqlSession级别，默认开启，并且不能关闭。 操作数据库时需要创建SqlSession对象，在对象中有一个HashMap用于存储缓存数据，不同的SqlSession之间缓存数据区域是互不影响的。 一级缓存的作用域是SqlSession范围的，当在同一个SqlSession中执行两次相同的Sql语句时，第一次执行完毕后会将结果保存到缓存中，第二次查询时直接从缓存中获取。 注意：如果SqlSession执行了DML操作（insert、update、delete），MyBatis必须将缓存清空以保证数据的准确性。 1234567891011121314public class Test01 { public static void main(String[] args) { InputStream inputStream=Test01.class.getClassLoader().getResourceAsStream(\"Config.xml\"); SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory=builder.build(inputStream); SqlSession sqlSession=sqlSessionFactory.openSession(); StudentRepository studentRepository=sqlSession.getMapper(StudentRepository.class); Student student=studentRepository.findById(2); System.out.println(student.getName()); Student student1=studentRepository.findById(2); System.out.println(student1.getName()); }} 结果: 查询结果有两个，但SQL语句只执行了一次 Mapper级别，默认关闭，可以开启 使用二级缓存时，多个SqlSession使用同一个Mapper的Sql语句操作数据库时，得到的数据会存在二级缓存区，同样是使用HashMap进行数据存储，相当于一级缓存，二级缓存的范围更大，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。 二级缓存是多个SqlSession共享的，其作用域是Mapper的同一个namespace，不同的SqlSession两次执行相同的namespace下的Sql语句，参数也相同，则第一次执行成功之后会将数据保存到二级缓存中，第二次可直接从二级缓存中取出数据。 MyBatis自带的二级缓存 在MyBatis主配置文件中（Config.xml）开启二级缓存 12345678&lt;settings&gt; &lt;!-- 打印sql--&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;!--开启延迟加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!--开启二级缓存--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;&lt;/settings&gt; Mapper.xml中配置二级缓存 1&lt;cache&gt;&lt;/cache&gt; 实体类实现序列化接口 1public class Student implements Serializable 测试 12345678910111213141516public class Test01 { public static void main(String[] args) { InputStream inputStream=Test01.class.getClassLoader().getResourceAsStream(\"Config.xml\"); SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory=builder.build(inputStream); SqlSession sqlSession=sqlSessionFactory.openSession(); StudentRepository studentRepository=sqlSession.getMapper(StudentRepository.class); Student student=studentRepository.findById(2); System.out.println(student.getName()); sqlSession.close(); //把sqlSession关闭，进行二级缓存测试 sqlSession=sqlSessionFactory.openSession(); studentRepository=sqlSession.getMapper(StudentRepository.class); Student student1=studentRepository.findById(2); System.out.println(student1.getName()); }} 测试结果： ehcache二级缓存 在pom.xml中添加依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache-core&lt;/artifactId&gt;&lt;version&gt;2.4.3&lt;/version&gt;&lt;/dependency&gt; 在resources文件夹下添加ehcache.xml 1234567891011121314&lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"../config/ehcache.xsd\"&gt; &lt;diskStore/&gt; &lt;defaultCache maxElementsInMemory=\"1000\" maxElementsOnDisk=\"10000000\" eternal=\"false\" overflowToDisk=\"false\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"120\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\"&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt; 在MyBatis主配置文件中（Config.xml）开启二级缓存 12345678&lt;settings&gt; &lt;!-- 打印sql--&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt; &lt;!--开启延迟加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!--开启二级缓存--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;&lt;/settings&gt; Mapper.xml中配置二级缓存 12345678&lt;cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"&gt; &lt;!--缓存创建之后，最后一次访问缓存的时间至缓存失效的时间间隔--&gt; &lt;property name=\"timeToIdleSeconds\" value=\"3600\"/&gt; &lt;!--缓存自创建时间起至失效的时间间隔--&gt; &lt;property name=\"timeToLiveSeconds\" value=\"3600\"/&gt; &lt;!--缓存回收策略，LRU表示移除近期使用最少的对象--&gt; &lt;property name=\"memoryStoreEvictionPolicy\" value=\"LRU\"/&gt;&lt;/cache&gt; MyBatis动态SQL 程序可以自动根据业务参数来决定SQL的组成。 if标签 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.AccountRepository\"&gt; &lt;select id=\"findByAccount\" parameterType=\"com.litao.entity.Account\" resultType=\"com.litao.entity.Account\"&gt; select * from account where &lt;if test=\"id!=null\"&gt; id=#{id} &lt;/if&gt; &lt;if test=\"username!=null\"&gt; and username=#{username} &lt;/if&gt; &lt;if test=\"password!=null\"&gt; and password=#{password} &lt;/if&gt; &lt;/select&gt;&lt;/mapper&gt; if标签可以自动根据表达式的结果来决定是否将对应的语句添加到SQL中，如果条件不成立则不添加，如果条件成立则添加。 where标签 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.AccountRepository\"&gt; &lt;select id=\"findByAccount\" parameterType=\"com.litao.entity.Account\" resultType=\"com.litao.entity.Account\"&gt; select * from account &lt;where&gt; &lt;if test=\"id!=null\"&gt; id=#{id} &lt;/if&gt; &lt;if test=\"username!=null\"&gt; and username=#{username} &lt;/if&gt; &lt;if test=\"password!=null\"&gt; and password=#{password} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; where标签可以自动判断是否要删除语句块中的and关键字，如果检测到where直接跟and拼接，则自动删除and，通常情况下 if 和 where 结合起来使用。 choose、when标签 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.AccountRepository\"&gt; &lt;select id=\"findByAccount\" parameterType=\"com.litao.entity.Account\" resultType=\"com.litao.entity.Account\"&gt; select * from account &lt;where&gt; &lt;choose&gt; &lt;when test=\"id!=null\"&gt; id=#{id} &lt;/when&gt; &lt;when test=\"username!=null\"&gt; username=#{username} &lt;/when&gt; &lt;when test=\"password\"&gt; password=#{password} &lt;/when&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; trim标签 trim标签中的prefix和suffix属性会被用来生成实际的SQL语句，会和标签内部的语句进行拼接，如果语句前后出现了prefixOverrides或者suffixOverrides属性中指定的值，MyBatis框架会自动将其删除。 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.AccountRepository\"&gt; &lt;select id=\"findByAccount\" parameterType=\"com.litao.entity.Account\" resultType=\"com.litao.entity.Account\"&gt; select * from account &lt;trim prefix=\"where\" prefixOverrides=\"and\"&gt; &lt;if test=\"id!=null\"&gt; id=#{id} &lt;/if&gt; &lt;if test=\"username!=null\"&gt; and username=#{username} &lt;/if&gt; &lt;if test=\"password!=null\"&gt; and password=#{password} &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt;&lt;/mapper&gt; set 标签 set标签用于update操作，会自动根据参数选择生成SQL语句。 123456789101112131415&lt;update id=\"update\" parameterType=\"com.litao.entity.Account\"&gt; update account &lt;set&gt; &lt;if test=\"id!=null\"&gt; id=#{id}, &lt;/if&gt; &lt;if test=\"username!=null\"&gt; username=#{username}, &lt;/if&gt; &lt;if test=\"password!=null\"&gt; password!=#{password} &lt;/if&gt; where id=#{id} &lt;/set&gt;&lt;/update&gt; foreach标签 foreach 标签可以迭代生成一系列值，这个标签主要用于SQL的in语句 1234567891011&lt;select id=\"findByIds\" parameterType=\"com.litao.entity.Account\"resultType=\"com.litao.entity.Account\"&gt; select * from account &lt;where&gt; &lt;foreach collection=\"ids\" open=\"id in (\" close=\")\" item=\"id\" separator=\",\"&gt; #{id} &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt;//select * from account where id in (?,?,?...);","link":"/2019/05/19/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%B8%89/"},{"title":"MyBatis框架学习二","text":"mysql ：8.0 入门案例测试 读取配置文件 创建SqlSessionFactory工厂 创建工厂mybatis使用了构建者模式（把对象的创建细节隐藏，让使用者直接调用方法即可拿到对象） 使用工厂生产SqlSession对象 生产SqlSession使用了工厂模式（解耦，即降低类之间的依赖关系） 使用SqlSession创建接口的代理对象 session.getMapper(Class type); 创建接口实现类使用了代理模式（不修改源码的基础上对已有方法增强） 使用代理对象执行方法 释放资源 注意事项：不要忘记在映射配置中告诉mybatis要把数据封装到哪个实体类中（设定resultType的值为全类名） 查询所有操作 123456789101112131415161718192021222324252627282930313233/*mybatis 入门案例 */public class MybatisTest { public static void main(String[] args) { //1. 读取配置文件 try { InputStream in= Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2. 创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder(); SqlSessionFactory factory=builder.build(in); //3. 使用工厂生产SqlSession对象 SqlSession session=factory.openSession(); //4. 使用SqlSession创建接口的代理对象 UserRepository userRepository=session.getMapper(UserRepository.class); //5. 使用代理对象执行方法 List&lt;User&gt; users=userRepository.findall(); for(User user:users){ System.out.println(user); } //6. 释放资源 session.close(); in.close(); } catch (IOException e) { e.printStackTrace(); } }} 测试结果： 查询操作代码大致分析 读取配置文件 解析xml ：dom4j selectList方法 根据配置文件的信息创建Connection对象（注册驱动，获取连接） 获取预处理对象PreparedStatement connection.preparedStatement(sql) 执行查询sql语句，返回ResultSet ResultSet resultSet =preparedStatement.executeQuery(); 遍历结构集 resultSet 用于封装 List list =new ArrayList(); while(resultSet.next(){ E element =(E) Class.forName(“全限定类名”).newInstance ()（对应xml中的resultType） 封装:把每个内容添加到element中，再把element加入到list中 根据反射的方式来根据名称获取属性并赋值 list.add(element); } 返回list return list； 执行上述方法需要提供两个信息： 连接信息（用来创建connection） 映射信息：sql语句和封装结果的实体类全限定名（resultType），把这两个信息组合起来定义成一个对象（Map） String Mapper（映射） com.litao.repository.UserRepository String ClassPath findall string sql 根据接口的字节码创建代理对象 public T getMapper(Class type){ /* 类加载器：它使用的和被代理的对象是相同的类加载器 代理对象要实现的接口：在被代理对象实现相同的接口 代理方式：它就是增强的方法，需要自己来提供。此处是InnvocationHandler的接口，需要写一个该接口的实现类，在实现类中调用selectList方法 */ Proxy.newProxyInstance（类加载器，代理对象要实现的接口字节码数组，代理方式） } 这个让我想到了Spring框架中的AOP（面向切面编程）中的代理方式 通过id查询操作 12User user=userRepository.findById(3);System.out.println(user); 查询结果： 通过id删除 123User user=new User(21412,\"小黄\",simpleDateFormat.parse(\"2017-07-15 15:00:05\"),\"女\",\"上海浦东新区\");userRepository.update(22,user);sqlSession.commit(); 修改操作 123User user=new User(21412,\"小黄\",simpleDateFormat.parse(\"2017-07-15 15:00:05\"),\"女\",\"上海浦东新区\");userRepository.update(22,user);sqlSession.commit(); 插入操作 这里使用的是Mybatis原生接口执行添加操作，但不推荐使用原生接口 为实体类创建对应的Mapper.xml,定义管理对象数据的SQL 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.Mapper.UserMapper\"&gt; &lt;!--添加数据--&gt; &lt;insert id=\"save\" parameterType=\"com.litao.entity.User\"&gt; insert into user(username,birthday,sex,address) values(#{username},#{birthday},#{sex},#{address}) &lt;/insert&gt;&lt;/mapper&gt; namespace 通常设置为文件所在包+文件名的形式 insert 标签表示执行添加操作 select 标签表示执行查询操作 update 标签表示更新操作 delete 标签表示删除操作 id 是实际调用Mybatis 方法时需要用到的参数 parameterType 是调用对应方法时参数的数据类型 在全局配置文件中注册UserMapper.xml 123&lt;mappers&gt; &lt;mapper resource=\"com/litao/Mapper/UserMapper.xml\"/&gt;&lt;/mappers&gt; 测试 12345678910111213141516171819202122public class Test { public static void main(String[] args) throws IOException{// InputStream inputStream=Test.class.getClassLoader().getResourceAsStream(\"SqlMapConfig.xml\"); InputStream inputStream= Resources.getResourceAsStream(\"SqlMapConfig.xml\"); SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory=builder.build(inputStream); SqlSession sqlSession=sqlSessionFactory.openSession(); String statement=\"com.litao.Mapper.UserMapper.save\"; SimpleDateFormat simpleDateFormat=new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\"); try { User user=new User(5,\"小红\",simpleDateFormat.parse(\"2017-07-15 15:00:05\"),\"女\",\"上海\"); sqlSession.insert(statement,user); sqlSession.commit(); sqlSession.close(); inputStream.close(); } catch (ParseException e) { e.printStackTrace(); }catch (IOException e){ e.printStackTrace(); } }} 级联查询 实体类： 12345678import lombok.Data;@Datapublic class Student { private long id; private String name; private Classes classes;} 12345678910import lombok.Data;import java.util.List;@Datapublic class Classes { private long id; private String name; private List&lt;Student&gt; students;} 一对一（一个学生对应一个班级） StudentRepository 12345import com.litao.entity.Student;public interface StudentRepository { public Student findById(long id);} StudentRepository.xml 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.StudentRepository\"&gt;&lt;resultMap id=\"studentMap\" type=\"com.litao.entity.Student\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"name\" property=\"name\"&gt;&lt;/result&gt; &lt;association property=\"classes\" javaType=\"com.litao.entity.Classes\"&gt; &lt;id column=\"cid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"cname\" property=\"name\"&gt;&lt;/result&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"findById\" parameterType=\"long\" resultMap=\"studentMap\"&gt; select s.id,s.name,c.id as cid,c.name as cname from student s,classes cwhere s.id = #{id} and s.cid = c.id &lt;/select&gt;&lt;/mapper&gt; 测试结果： Student(id=2, name=李四, classes=Classes(id=2, name=6班, students=null)) 一对多（一个班级对应多个学生） ClassesRepository 12345import com.litao.entity.Classes;public interface ClassesRepository { public Classes findById(long id);} ClassesRepository.xml 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.litao.repository.ClassesRepository\"&gt; &lt;resultMap id=\"classesMap\" type=\"com.litao.entity.Classes\"&gt; &lt;id column=\"cid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"cname\" property=\"name\"&gt;&lt;/result&gt; &lt;collection property=\"students\" ofType=\"com.litao.entity.Student\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findById\" parameterType=\"long\" resultMap=\"classesMap\"&gt; select s.id,s.name,c.id as cid,c.name as cname from student s,classes cwhere c.id = #{id} and s.cid = c.id &lt;/select&gt;&lt;/mapper&gt; 测试结果： Classes(id=2, name=6班, students=[Student(id=1, name=张三, classes=null), Student(id=2, name=李四, classes=null), Student(id=3, name=王五, classes=null)] ) 多对多 多对多即由多个一对多组成","link":"/2019/05/19/Mybatis%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E4%BA%8C/"},{"title":"Servlet与Jsp学习一","text":"什么是Servlet（控制层的访问） servlet是Java Web开发的基石，与平台无关的服务器组件，它是运行在Servlet容器/Web应用服务器/Tomcat，负责与客户端进行通信 servlet的功能： 创建并返回基于客户请求的动态Html页面 与数据库进行通信 如何使用 Servlet本身是一组接口，自定义一个类，并且实现Servlet接口，这个类就具备了接收客户端请求以及做出响应的功能。 123456789101112131415161718192021222324252627282930313233package com.litao.servlet;import javax.servlet.*;import java.io.IOException;public class MyServlet implements Servlet { @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponseservletResponse) throws ServletException, IOException { String id = servletRequest.getParameter(\"id\"); System.out.println(\"我是Servlet，我已经接收到了客户端发来的请求，参数是\"+id); servletResponse.setContentType(\"text/html;charset=UTF-8;//解决中文输出乱码问题 servletResponse.getWriter().write(\"客户端你好，我已接收到你的请求\"); } @Override public String getServletInfo() { return null; } @Override public void destroy() { }} 浏览器不能直接访问Servlet文件，只能通过映射的方式来间接访问Servlet，映射需要开发者手动配置，有两种配置方式。 基于xml的配置方式 在web.xml中添加 123456789&lt;servlet&gt; &lt;servlet-name&gt;MyServlet01&lt;/servlet-name&gt; &lt;servlet-class&gt;com.litao.servlet.MyServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;!--映射--&gt; &lt;servlet-name&gt;MyServlet01&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 基于注解的方式 1234@WebServlet(\"/demo1\")public class MyServlet implements Servlet { } 上述两种配置方式结果完全一致，将demo1与MyServlet进行映射，即在浏览器地址栏中直接访问domo1就可以映射到MyServlet Servlet生命周期 当浏览器访问servlet时，Tomcat会查询当前servlet的实例化对象是否存在，如果不存在，则通过反射机制动态创建对象，如果存在，直接执行第三步 调用init（）方法完成初始化操作（只调用一次） 调用service方法完成业务逻辑操作（当刷新页面时重新调用服务，不用再初始化） 关闭tomcat时，会调用destory方法，释放当前对象所占用的资源 Servlet 的生命周期方法：无参构造函数、init 无参构造函数，只调用一次，创建对象（通过反射机制来创建对象） init只调用一次，初始化对象 service调用N次，用来执行业务方法 destory只调用一次，销毁对象 ServletConfig 该接口是用来描述Servlet的基本信息的 getServletName（） 返回Servlet的名称，即全类名（带着包名的类名） getInitParameter(String key) 获取init参数的值（在web.xml中配置，&lt;init-param&gt;&lt;/init-parm&gt;） getInitParameterNames() 返回所有的 initParamter 的 name 值，一般用作遍历初始化参数 getServletContext 返回ServletContext对象，它是Servlet的上下文，是整个Servlet的管理者 ServletConfig与ServletContext的区别： ServletConfig作用于某个Servlet实例，每个Servlet都有对应的ServletConfig ServletContext作用于整个web应用，一个Web应用对应一个ServletContext，多个Servlet实例对应一个ServletContext ServletConfig是局部对象，ServletContext是全局对象 Servlet的层次结构 Servlet --》GenericServlet --》HttpServlet GenericServlet 实现了Servlet接口，同时为它的子类屏蔽了不常用的方法,子类只需重写Service方法。 HttpServlet继承GenericServlet ，根据请求类型进行分发处理，Get进入doGet方法，Post进入doPost方法 开发者自定义的Servlet只需要继承HttpServlet即可，重写doGet和doPost 1234567891011121314151617181920212223package com.litao.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/test\")public class TestServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp)throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp)throws ServletException, IOException { }} 什么是 Jsp Jsp本质上是一个Servlet，Jsp主要负责与用户交互，将最终的界面呈现给用户。Jsp是一个Html+Js+Css+Java的混合文件。 当服务器接收到一个后缀是Jsp的请求时，将该请求交给Jsp引擎去处理，每一个Jsp页面第一次被访问时，Jsp引擎会将它翻译成一个Servlet文件（保存在Tomcat的Work文件夹下），再由Web容器调用Servlet完成响应。 单纯从开发的角度看，Jsp就是在Html中嵌入了Java程序。 有3种嵌入方式： Jsp脚本：执行Java逻辑代码 &lt;% Java 代码 %&gt; Jsp声明：定义Java方法 &lt;% 声明Java 方法 %&gt; Jsp表达式：把Java对象直接输出到Html页面中 &lt;%= Java 变量 %&gt; 例子： 1234567891011&lt;%! public String test(){ return \"HelloWorld\";}%&gt;&lt;%String str = test();%&gt;&lt;%=str%&gt; Jsp的9个内置对象 request: 表示一次请求， HttpServletRequest response：表示一次响应， HttpServletResponse pageContext：页面上下文，获取页面信息， PageContext session：表示一次会话，保存用户信息， HttpSession application：表示当前Web应用，全局对象，保存所有用户共享信息，ServletContext config：当前JSP对应的Servlet的ServletConfig对象，获取当前Servlet的信息 out：向浏览器输出数据，JspWriter page：当前Jsp对应的Servlet对象， Servlet exception：表示JSP页面发生的异常，Exception 常用的有request、response、pageContext、session、application request 常用方法： String getParameter（String key） 获取客户端传来的参数，如?id=1&amp;name=tom void setAttribute（String key,Object value） 通过键值对的形式保存数据 Object getAttribute（String key） 通过key取出value RequestDispatcher getRequestDispatcher(String path) 返回一个RequestDispatcher对象，该对象的forward方法用于请求转发 String[] getParameterValues（） 获取客户端传来的多个同名参数 如name=li&amp;name=tom void setCharacterEncoding（String charset） 获取每个请求的编码 reponse常用方法： sendRedirect（String path） 重定向，页面之间的跳转 转发：同一个请求在服务器之间传递，地址栏不变，也叫服务器跳转 重定向：由客户端发送一次新的请求来访问跳转后的目标资源，地址栏改变，也叫客户端跳转 foward（转发）与redirect（重定向）的区别： forward是发生在服务器端，效率更好，而redirect是发生在了客户端 forward是请求转发，只是一次请求，而redirect是相当于了两次请求（第一次请求是客户端发过来的Http请求，服务器的Redirect命令会对该请求发回响应，客户端浏览器得到响应后，会再发送一个新的请求，这个就是第二次请求，它与第一次请求没有关系，所以不会带有第一次请求的信息） forward不会改变客户端的URL显示，而redirect会改变客户端的URL的显示 forward不会销毁request，可以传递request参数，而redirect会销毁request forward只是在原有request请求上再做一次资源的跳转，因此不能访问外部资源，而redirect可以访问外部资源，例如百度。 Session （用户会话） 服务器无法识别每一次Http请求的出处（不知道来自哪个终端），它只会接收到一个请求信号，所以将用户的响应发送给其他人时，必须有一种技术来让服务器知道请求来自哪，这就是会话技术。 会话：就是客户端和服务器之间发生的一系列连续的请求和响应的过程，打开浏览器进行操作到关闭浏览器的过程 会话状态：指服务器和浏览器在会话过程中产生的状态信息，借助于会话状态，服务器能够把属于同一次会话的一系列请求和响应关联起来。 实现会话的两种方式： session cookie 属于同一次会话的请求都有一个相同的标识符 ，sessionID session常用的方法 HttpSession session = request.getSession() 得到session String getId（） 获取sessionID void setMaxInactiveInterval（int interval） 设置session的失效时间，单位为秒，（值为-1 时永不失效） int getMaxMaxInactiveInterval() 获取当前session的失效时间 void setAttribute（String key,Object value） 通过键值对的形式来存储数据 Object getAttribute（String key） 通过key取出value void removeAttribute（String key） 通过键删除对应数据 session.invalidate() 注销request的所有session（可用来退出用户登录） 例如存储用户信息： session.setAttribute(&quot;name&quot;,&quot;admin&quot;) 存 session.getAttribute(&quot;name&quot;) 取 session生命周期： 服务端： 只要Web应用重启或关闭就销毁 客户端： 只要浏览器关闭就销毁 Cookie Cookie是服务端在HTTP响应中附带给浏览器的一个小文本文件，一旦浏览器保存了某个Cookie，在之后的请求和响应过程中，会将此Cookie来回传递，这样就可以通过Cookie这个载体完成客户端和服务端的数据交互。 创建Cookie 12Cookie cookie = new Cookie(\"name\",\"tom\");response.addCookie(cookie); 读取Cookie 1234Cookie[] cookies = request.getCookies();for (Cookie cookie:cookies){ out.write(cookie.getName()+\":\"+cookie.getValue()+\"&lt;br/&gt;\");} Cookie 常用的方法： void SetMaxAge（int age） 设置session的有效时间，单位为秒 int getMaxAge() 获取Cookie的有效时间 int getMaxAge() 获取Cookie的有效时间 int getMaxAge() 获取Cookie的有效时间 例如存储用户信息： response.addCookie(new Cookie(name,&quot;tom&quot;)) 存 取 123456Cookie[] cookies = request.getCookies();for (Cookie cookie:cookies){ if(cookie.getName().equals(\"name\")){ out.write(\"欢迎回来\"+cookie.getValue()); }} Cookie生命周期： 服务端： 不随服务断的重启而销毁 客户端： 默认是只要关闭浏览器就销毁，但可以通过setMaxAge() 方法来设置有效时间。一旦设置了有效时间，则不随浏览器的关闭而销毁，而是由设置的时间来决定。（可通过setMaxage（0）来退出用户登录） Session 与Cookie的区别 Session 保存在服务器中，Cookie保存在个人浏览器中 Session 保存的数据类型是Object ，Cookie保存的数据类型是String Session会随着会话的结束而销毁，Cookie可以长期保存在浏览器中，与会话无关 Session保存重要信息， Cookie保存不重要信息","link":"/2019/02/17/Servlet%E4%B8%8EJsp%E5%AD%A6%E4%B9%A0%E4%B8%80/"},{"title":"Servlet与Jsp学习三","text":"Filter过滤器 与Servlet类似，Filter是Java Web提供的一个接口，只需要自定义一个类并且实现该接口即可。 12345678910111213package com.litao.filter;import javax.servlet.*;import java.io.IOException;public class CharacterFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponseservletResponse, FilterChain filterChain) throws IOException, ServletException { servletRequest.setCharacterEncoding(\"UTF-8\"); filterChain.doFilter(servletRequest,servletResponse); }} 注意：doFilter ⽅法中处理完业务逻辑之后，必须添加 1filterChain.doFilter(servletRequest,servletResponse); 否则请求/响应无法向后传递，⼀直停留在过滤器中。 作用： 用来拦截传入的请求和传出的响应 修改或以某中方式处理正在客户端和服务端之间交换的数据流 使用 基于web.xml配置Filter 12345678&lt;filter&gt; &lt;filter-name&gt;charcater&lt;/filter-name&gt; &lt;filter-class&gt;com.litao.filter.CharacterFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;charcater&lt;/filter-name&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 基于注解配置Filter 1234@WebFilter(\"/login\")public class CharacterFilter implements Filter {} 上述两种配置方式，结果一样 Filter生命周期 当Tomcat启动时，通过反射机制调用Filter的无参构造函数创建实例化对象，同时调用init方法实现初始化，doFilter方法调用多次，当Tomcat关闭时，调用destoty来销毁Filter对象 无参构造函数：只调用一次，当Tomcat启动时调用（Filter一定要进行配置） init方法：只调用一次，当Filter的实例化对象创建完成之后调用 doFilter：调用多次，访问Filter的业务逻辑都写在Filter中 destory：只调用一次，Tomcat关闭时使用 同时配置多个Filter时，Filter的调用顺序是由web.xml的配置顺序来决定的，写在上面的配置先调用，因为web.xml是从上到下顺序读取的。 Filter使用场景举例 统一处理中文乱码 屏蔽敏感词 12345678910111213141516171819package com.litao.filter;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import java.io.IOException;@WebFilter(\"/test\")public class WordFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponseservletResponse, FilterChain filterChain) throws IOException, ServletException { servletRequest.setCharacterEncoding(\"UTF-8\"); //将\"敏感词\"替换成\"***\" String name = servletRequest.getParameter(\"name\"); name = name.replaceAll(\"敏感词\",\"***\"); servletRequest.setAttribute(\"name\",name); filterChain.doFilter(servletRequest,servletResponse); }} 控制资源访问权限 123456789101112131415161718192021222324252627package com.litao.filter;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;@WebFilter(\"/download.jsp\")public class DownloadFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponseservletResponse, FilterChain filterChain) throws IOException, ServletException{ HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; HttpSession session = request.getSession(); String name = (String) session.getAttribute(\"name\"); if(name == null){ //不是登录状态 response.sendRedirect(\"/login.jsp\"); }else{ filterChain.doFilter(servletRequest,servletResponse); } }} 文件的上传与下载 文件上传 Jsp input的type设置为file form表单的method设置post，get请求只会将文件名传给服务器，而不是文件本身 form表单的enctype设置multipart/form-data，以二进制的形式传输数据 12345678910111213&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form enctype=\"multipart/form-data\" action=\"/upload\" method=\"post\"&gt; &lt;input name=\"desc\" type=\"text\"/&gt;&lt;br/&gt; &lt;input name=\"text\" type=\"file\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"上传\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; Servlet fileupload组件可以将所有的请求信息都解析成FileItem对象，可以通过FileItem对象的操作完成上传，体现面向对象的思想。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.litao.servlet;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.FileUploadException;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.*;import java.util.List;@WebServlet(\"/upload\")public class UploadServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp)throws ServletException, IOException { } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp)throws ServletException, IOException {// //通过输⼊流获取客户端传来的数据流// InputStream inputStream = req.getInputStream();// Reader reader = new InputStreamReader(inputStream);// BufferedReader bufferedReader = new BufferedReader(reader);// //通过输出流将数据流输出到本地硬盘// //获取⽂件夹的绝对路径// String path = req.getServletContext().getRealPath(\"file/copy.txt\");// OutputStream outputStream = new FileOutputStream(path);// Writer writer = new OutputStreamWriter(outputStream);// BufferedWriter bufferedWriter = new BufferedWriter(writer);// String str = \"\";// while((str = bufferedReader.readLine())!=null){// System.out.println(str);// bufferedWriter.write(str);// }// bufferedWriter.close();// writer.close();// outputStream.close();// bufferedReader.close();// reader.close();// inputStream.close(); try { DiskFileItemFactory fileItemFactory = new DiskFileItemFactory(); ServletFileUpload servletFileUpload = new ServletFileUpload(fileItemFactory); List&lt;FileItem&gt; list = servletFileUpload.parseRequest(req); for(FileItem fileItem : list){ if(fileItem.isFormField()){ String name = fileItem.getFieldName(); String value = fileItem.getString(\"UTF-8\"); System.out.println(name+\":\"+value); }else{ String fileName = fileItem.getName(); long size = fileItem.getSize(); System.out.println(fileName+\":\"+size+\"Byte\"); InputStream inputStream = fileItem.getInputStream();// Reader reader = new InputStreamReader(inputStream);// BufferedReader bufferedReader = new BufferedReader(reader); String path =req.getServletContext().getRealPath(\"file/\"+fileName); OutputStream outputStream = new FileOutputStream(path);// Writer writer = new OutputStreamWriter(outputStream);// BufferedWriter bufferedWriter = new BufferedWriter(writer); int temp = 0; while((temp = inputStream.read())!=-1){ outputStream.write(temp); }// bufferedWriter.close();// writer.close(); outputStream.close();// bufferedReader.close();// reader.close(); inputStream.close(); System.out.println(\"上传成功\"); } } } catch (FileUploadException e) { e.printStackTrace(); } }} 文件下载 Jsp 12345678910&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;文件下载&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"/test/download?type=img\"&gt;图片&lt;/a&gt; &lt;a href=\"/test/download?type=txt\"&gt;文本&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; Servlet 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.litao.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;@WebServlet(\"/download\")public class DownLoadServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String type=req.getParameter(\"type\"); String filename=\"\"; switch (type){ case\"img\": filename=\"1.png\"; break; case\"txt\": filename=\"1.txt\"; break; } //设置响应方式 resp.setContentType(\"application/x-msdownload\"); //设置下载后的文件名 resp.setHeader(\"Content-Disposition\",\"attachment;filename=\"+filename); //获取输出流 OutputStream outputStream=resp.getOutputStream(); String path=req.getServletContext().getRealPath(\"file/\"+filename); InputStream inputStream=new FileInputStream(path); int temp=0; while ((temp=inputStream.read())!=-1){ outputStream.write(temp); } inputStream.close(); outputStream.close(); }} Ajax 概述 Asynchronous JavaScript And XML: 异步的JavaScript和XML Ajax是一种交互方式，异步加载，客户端和服务器的数据交互更新在局部页面的技术，不需要刷新整个页面（局部更新） 优点： 局部刷新，效率更高 用户体验更好 Ajax原理图 基于JQuery的Ajax 语法 $.ajax({属性}) 常用的属性参数： url：请求的后端服务地址 type：请求方式，默认 get data：请求参数 data Type：服务器返回的数据类型，text/json success：请求成功的回调函数 error：请求失败的回调函数 complete：请求完成的回调函数（无论成功或者失败，都会调用） 例子 12345678910111213141516171819202122232425262728&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.3.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function(){ var btn = $(\"#btn\"); btn.click(function(){ $.ajax({ url:'/test', type:'post', data:'id=1', dataType:'text', success:function(data){ var text = $(\"#text\"); text.before(\"&lt;span&gt;\"+data+\"&lt;/span&gt;&lt;br/&gt;\"); } }); }); }) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input id=\"text\" type=\"text\"/&gt;&lt;br/&gt; &lt;input id=\"btn\" type=\"button\" value=\"提交\"/&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324package com.litao.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/test\")public class TestServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp)throws ServletException, IOException { String id = req.getParameter(\"id\"); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } String str = \"Hello World\"; resp.getWriter().write(str); }} 传统数据交互与Ajax数据交互的对比 客户端请求的方式不同： 传统：浏览器发送同步请求 Ajax：异步引擎对象发送异步请求 服务器响应的方式不同： 传统：响应一个完整的Jsp页面（视图） Ajax：响应需要的数据 客户端处理的方式不同： 传统：需要等待服务器完成响应并且重新加载整个页面之后，用户才能进行后续的操作 Ajax：动态更新页面中的局部内容，不影响用户的其他操作 Json 概述 JavaScript Object Notation ,一种轻量级数据交互格式，完成Js与Java等开发语言对象数据之间的转换。 客户端和服务器之间传递对象数据，需要用JSON格式 123456789101112package com.litao.entity;import lombok.Data;@Data@AllArgsConstructorpublic class User { private Integer id; private String name; private Double score;}User user = new User(1,\"张三\",95); 12345var user = { id:1, name:\"张三\", score:95} 例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-3.3.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function(){ //修改省份 $(\"#province\").change(function () { var id = $(this).val(); $.ajax({ url:\"/location\", type:\"POST\", data:\"id=\"+id+\"&amp;type=province\", dataType:\"JSON\", success:function(data){ var content = \"\"; var cities = data.cities; for(var i=0;i&lt;cities.length;i++){ content += \"&lt;option&gt;\"+cities[i]+\"&lt;/option&gt;\"; } $(\"#city\").html(content); content = \"\"; var areas = data.areas; for(var i=0;i&lt;areas.length;i++){ content += \"&lt;option&gt;\"+areas[i]+\"&lt;/option&gt;\"; } $(\"#area\").html(content); } }); }); //修改城市 $(\"#city\").change(function(){ var id = $(this).val(); $.ajax({ url:\"/location\", type:\"POST\", data:\"id=\"+id+\"&amp;type=city\", dataType:\"JSON\", success:function(data){ var content = \"\"; for(var i=0;i&lt;data.length;i++){ content += \"&lt;option&gt;\"+data[i]+\"&lt;/option&gt;\"; } $(\"#area\").html(content); } }); }); }); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; 省：&lt;select id=\"province\"&gt; &lt;option value=\"陕⻄省\"&gt;陕⻄省&lt;/option&gt; &lt;option value=\"河南省\"&gt;河南省&lt;/option&gt; &lt;option value=\"江苏省\"&gt;江苏省&lt;/option&gt; &lt;/select&gt; 市：&lt;select id=\"city\"&gt; &lt;option value=\"⻄安市\"&gt;⻄安市&lt;/option&gt; &lt;option value=\"宝鸡市\"&gt;宝鸡市&lt;/option&gt; &lt;option value=\"渭南市\"&gt;渭南市&lt;/option&gt; &lt;/select&gt; 区：&lt;select id=\"area\"&gt; &lt;option&gt;雁塔区&lt;/option&gt; &lt;option&gt;莲湖区&lt;/option&gt; &lt;option&gt;新城区&lt;/option&gt; &lt;/select&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324package com.litao.entity;import java.util.List;public class Location { private List&lt;String&gt; cities; private List&lt;String&gt; areas; public List&lt;String&gt; getCities() { return cities; } public void setCities(List&lt;String&gt; cities) { this.cities = cities; } public List&lt;String&gt; getAreas() { return areas; } public void setAreas(List&lt;String&gt; areas) { this.areas = areas; }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.litao.servlet;import com.southwind.entity.Location;import net.sf.json.JSONArray;import net.sf.json.JSONObject;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;@WebServlet(\"/location\")public class LocationServlet extends HttpServlet { private static Map&lt;String, List&lt;String&gt;&gt; cityMap; private static Map&lt;String,List&lt;String&gt;&gt; provinceMap; static { cityMap = new HashMap&lt;&gt;(); List&lt;String&gt; areas = new ArrayList&lt;&gt;(); //⻄安 areas.add(\"雁塔区\"); areas.add(\"莲湖区\"); areas.add(\"新城区\"); cityMap.put(\"⻄安市\",areas); //宝鸡 areas = new ArrayList&lt;&gt;(); areas.add(\"陈仓区\"); areas.add(\"渭宾区\"); areas.add(\"新城区\"); cityMap.put(\"宝鸡市\",areas); //渭南 areas = new ArrayList&lt;&gt;(); areas.add(\"临渭区\"); areas.add(\"⾼新区\"); cityMap.put(\"渭南市\",areas); //郑州 areas = new ArrayList&lt;&gt;(); areas.add(\"郑州A区\"); areas.add(\"郑州B区\"); cityMap.put(\"郑州市\",areas); //洛阳 areas = new ArrayList&lt;&gt;(); areas.add(\"洛阳A区\"); areas.add(\"洛阳B区\"); cityMap.put(\"洛阳市\",areas); provinceMap = new HashMap&lt;&gt;(); List&lt;String&gt; cities = new ArrayList&lt;&gt;(); cities.add(\"⻄安市\"); cities.add(\"宝鸡市\"); cities.add(\"渭南市\"); provinceMap.put(\"陕⻄省\",cities); cities = new ArrayList&lt;&gt;(); cities.add(\"郑州市\"); cities.add(\"洛阳市\"); cities.add(\"开封市\"); provinceMap.put(\"河南省\",cities); cities = new ArrayList&lt;&gt;(); cities.add(\"南京市\"); cities.add(\"苏州市\"); cities.add(\"南通市\"); provinceMap.put(\"江苏省\",cities); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp)throws ServletException, IOException { String type = req.getParameter(\"type\"); resp.setCharacterEncoding(\"UTF-8\"); String id = req.getParameter(\"id\"); switch (type){ case \"city\": List&lt;String&gt; areas = cityMap.get(id); JSONArray jsonArray = JSONArray.fromObject(areas); resp.getWriter().write(jsonArray.toString()); break; case \"province\": List&lt;String&gt; cities = provinceMap.get(id); String city = cities.get(0); List&lt;String&gt; cityAreas = cityMap.get(city); Location location = new Location(); location.setCities(cities); location.setAreas(cityAreas); JSONObject jsonObject = JSONObject.fromObject(location); resp.getWriter().write(jsonObject.toString()); break; } }}","link":"/2019/02/19/Servlet%E4%B8%8EJsp%E5%AD%A6%E4%B9%A0%E4%B8%89/"},{"title":"Servlet与Jsp学习二","text":"Jsp 4大内置对象作用域 page、request、session、application 都具有setAttribute和getAttribute方法 page的作用域： 对应的内置对象是pageContext request作用域： 对应的内置对象是requset session的作用域：对应的内置对象是session application的作用域：对应的内置对象是application page &lt; request &lt; session &lt; application page只在当前页面有效 request在一次请求内有效 session在一次会话中有效 application对应整个web应用 application例子： 网址访问量统计： 123456789101112&lt;% Integer count = (Integer) application.getAttribute(\"count\"); if(count == null){ count = 1; application.setAttribute(\"count\",count); }else{ count++; application.setAttribute(\"count\",count); }%&gt;您是当前的第&lt;%= count %&gt;位访客 EL表达式 Expression Language 表达式语言，替代Jsp页面中数据访问时的复杂编码，可以非常便捷地取出域对象（pageContext、request、session、application）中保存的数据，前提是一定要先setAttribute，EL就相当于在简化getAtrribute。 使用 ${ 变量名 } 变量名就是setAttribute对应的key值 EL表达式对4中域对象的默认查找顺序： pageContext --》request - -》 session --》 application 按照上述的顺序进行查找，找到立即返回，如果在application中也无法找到，则返回null 指定作用域查找 pageContext： ${pageScope.变量名} request： ${requestScope.变量名} session： ${sessionScope.变量名} application： ${applicationScope. 变量名} 数据级联 12345678910111213141516171819&lt;% User user = new User(1,\"张三\",86.5,new Address(1,\"上海\")); System.out.println(user.toString()); pageContext.setAttribute(\"user\",user); %&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;成绩&lt;/th&gt; &lt;th&gt;地址&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;${user.id}&lt;/td&gt; &lt;td&gt;${user.name}&lt;/td&gt; &lt;td&gt;${user.score}&lt;/td&gt; &lt;td&gt;${user.address}&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; user.id 调用的是id方法： 把 id 变为 Id 找到 getId () 方法 EL执行表达式 12345678910111213${num1&amp;&amp;num2}&amp;&amp; || ! &lt; &gt; &lt;= &lt;= ==&amp;&amp; and|| or! not== eq!= ne&lt; lt&gt; gt&lt;= le&gt;= geempty 变量为 null，⻓度为0的String， size为0的集合 JSTL JSP Standard Tag Library JSP 标准标签库，JSP为开发者提供的一系列的标签，使用这些标签可以完成一些逻辑处理，比如循环遍历集合，让代码更加简洁。 JSTL 侧重于逻辑处理 EL负责展示数据 JSTL优点： 提供了统一的标签 可以用于编写各种动态功能 使用 添加依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt; 在Jsp页面开始的地方导入JSTL核心标签库 1&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt; JSTL核心标签库常用标签： set、out、remove、catch set：向域对象中添加数据 12345678910111213141516&lt;% requset.setAttribute(key,value)%&gt;&lt;c:set var=\"name\" value=\"tom\" scope=\"request\"&gt;&lt;/c:set&gt;${requestScope.name}&lt;%User user = new User(1,\"张三\",66.6,new Address(1,\"上海\"));request.setAttribute(\"user\",user);%&gt;${user.name}&lt;hr/&gt;&lt;c:set target=\"${user}\" property=\"name\" value=\"李四\"&gt;&lt;/c:set&gt;${user.name} out：输出域对象中的数据 123&lt;c:set var=\"name\" value=\"tom\"&gt;&lt;/c:set&gt;&lt;c:out value=\"${name}\" default=\"未定义\"&gt;&lt;/c:out&gt; remove：删除域对象中的数据 123&lt;c:remove var=\"name\" scope=\"page\"&gt;&lt;/c:remove&gt;&lt;c:out value=\"${name}\" default=\"未定义\"&gt;&lt;/c:out&gt; catch：捕捉异常 123456&lt;c:catch var=\"error\"&gt; &lt;% int a = 10/0; %&gt;&lt;/c:catch&gt;${error} 条件标签： if 、choose 123456789&lt;c:set var=\"num1\" value=\"1\"&gt;&lt;/c:set&gt;&lt;c:set var=\"num2\" value=\"2\"&gt;&lt;/c:set&gt;&lt;c:if test=\"${num1&gt;num2}\"&gt;ok&lt;/c:if&gt;&lt;c:if test=\"${num1&lt;num2}\"&gt;fail&lt;/c:if&gt;&lt;hr/&gt;&lt;c:choose&gt; &lt;c:when test=\"${num1&gt;num2}\"&gt;ok&lt;/c:when&gt; &lt;c:otherwise&gt;fail&lt;/c:otherwise&gt;&lt;/c:choose&gt; 迭代标签：forEach 1234&lt;c:forEach items=\"${list}\" var=\"str\" begin=\"2\" end=\"3\" step=\"2\"varStatus=\"sta\"&gt; ${sta.count}、${str}&lt;br/&gt;&lt;/c:forEach&gt; 格式化标签库常用标签 1&lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %&gt; 1234567&lt;%request.setAttribute(\"date\",new Date());%&gt;&lt;fmt:formatDate value=\"${date}\" pattern=\"yyyy-MM-dd HH:mm:ss\"&gt;&lt;/fmt:formatDate&gt;&lt;br/&gt;&lt;fmt:formatNumber value=\"32145.23434\" maxIntegerDigits=\"2\"maxFractionDigits=\"3\"&gt;&lt;/fmt:formatNumber&gt; 函数标签库常用标签 1&lt;%@ taglib prefix=\"fn\" uri=\"http://java.sun.com/jsp/jstl/functions\" %&gt; 12345678910&lt;%request.setAttribute(\"info\",\"Java,C\");%&gt;${fn:contains(info,\"Python\")}&lt;br/&gt;${fn:startsWith(info, \"Java\")}&lt;br/&gt;${fn:endsWith(info, \"C\")}&lt;br/&gt;${fn:indexOf(info, \"va\")}&lt;br/&gt;${fn:replace(info, \"C\",\"Python\")}&lt;br/&gt;${fn:substring(info, 2, 3)}&lt;br/&gt;${fn:split(info, \",\")[0]}-${fn:split(info, \",\")[1]}","link":"/2019/02/18/Servlet%E4%B8%8EJsp%E5%AD%A6%E4%B9%A0%E4%BA%8C/"},{"title":"c3p0连接池","text":"概述 数据库连接对象是通过DriverManager来获取的，每次获取都需要向数据库获取数据连接，验证用户名和密码，执行完SQL语句断开连接，这样的方式会造成资源的浪费，数据资源没有得到很好的重复利用。可以使用数据库连接池解决该问题。 数据库连接池的基本思想就是为数据库建立一个缓冲池，预先向缓冲池放入一定数量的连接对象，当需要获取数据库连接的时候，只需要从缓冲池取出一个对象，用完之后再放回缓冲池中，供下一次请求使用，做到了资源的重复利用，允许程序重复使用一个现有的数据库连接对象，而不需要重新创建。 当数据库连接池没有空闲的连接时，新的请求就会进入等待队列，等待其他线程释放连接。 c3p0连接池实现 JDBC的数据库连接池使用javax.sql.DataSource接口来完成的，DataSource是Java官方提供的的接口，使用的时候开发者不需要自己来实现该接口，可以使用第三方的工具，如c3p0，DBCP，Druid，HikariCP","link":"/2019/02/21/c3p0%E8%BF%9E%E6%8E%A5%E6%B1%A0/"}],"tags":[{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"Mysql","slug":"Mysql","link":"/tags/Mysql/"},{"name":"MyBatis","slug":"MyBatis","link":"/tags/MyBatis/"},{"name":"JDBC","slug":"JDBC","link":"/tags/JDBC/"},{"name":"Servlet Jsp","slug":"Servlet-Jsp","link":"/tags/Servlet-Jsp/"},{"name":"数据库连接池","slug":"数据库连接池","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"}],"categories":[{"name":"Java Web","slug":"Java-Web","link":"/categories/Java-Web/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}